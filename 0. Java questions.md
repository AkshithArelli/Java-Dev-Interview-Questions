# 1. OOPs

There are four main pillars of OOPS:

	1.	Encapsulation
	2.	Abstraction
	3.	Inheritance
	4.	Polymorphism

â¸»

â­ 1. Encapsulation

Encapsulation means wrapping data and methods into a single unit (a class) and restricting direct access to the data using access modifiers.

It protects data from unintended modifications.

Simple Example
```java
class BankAccount {
    private double balance; // hidden data

    public void deposit(double amount) {
        balance += amount;
    }

    public double getBalance() {
        return balance;
    }
}
```
ğŸ‘‰ balance is private â†’ cannot access directly â†’ controlled using getter/setter.

ğŸ¯ Key point to mention: â€œEncapsulation ensures data protection.â€

	â€¢	Data lives inside the class
	â€¢	Only methods inside the class can modify it

This is literally the meaning of encapsulation:

â€œWrapping data + methods together as one unitâ€

â¸»

â­ 2. Abstraction

Abstraction means showing only the essential details and hiding unnecessary internal complexity.

Example
```java
abstract class Payment {
    abstract void pay();
}

class CreditCardPayment extends Payment {
    void pay() {
        System.out.println("Payment done using credit card");
    }
}
```

```java
Payment payment = new CreditCardSystem();
payment.pay();
```
You donâ€™t need to know how the credit card works internally.

ğŸ¯ Key point: â€œAbstraction reduces complexity and focuses on what an object does, not how it does it.â€

Think of it as:
ğŸ‘‰ â€œI give you the function, but I hide the internal mechanics.â€

You only see the idea of paying, not the details

â¸»

â­ 3. Inheritance

Inheritance allows one class (child/subclass) to acquire properties and methods of another class (parent/superclass).

It promotes code reusability.

Example
```java
class Animal {
    void eat() {
        System.out.println("Animal eats");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("Dog barks");
    }
}
```
ğŸ‘‰ Dog gets eat() method without writing it again.
ğŸ¯ Key point: â€œInheritance helps with reusability and hierarchical relationships.â€

â¸»

â­ 4. Polymorphism

Polymorphism means same method name, different behavior.

There are two types:

	â€¢	Compile-time polymorphism â†’ Method Overloading
	â€¢	Runtime polymorphism â†’ Method Overriding

â¸»

Compile-time Polymorphism (Overloading)
```java
class Calculator {
    int add(int a, int b) { return a+b; }
    int add(int a, int b, int c) { return a+b+c; }
}
```

â¸»

Runtime Polymorphism (Overriding)
```java
class Animal {
    void sound() { System.out.println("Animal makes sound"); }
}

class Dog extends Animal {
    @Override
    void sound() { System.out.println("Dog barks"); }
}
```
ğŸ¯ Key point: â€œPolymorphism provides flexibility to use one interface with multiple implementations.â€

â¸»
Extras:

5. Class vs Object
   
	â€¢	Class â†’ Blueprint
	â€¢	Object â†’ Instance of class

â¸»

6. Interface
   
	â€¢	100% abstraction (before Java 8)
	â€¢	Can have default and static methods
```java
interface Vehicle {
    void start();
}
```

â¸»

7. Abstract Class
   
	â€¢	Cannot be instantiated
	â€¢	Can contain abstract + concrete methods
	â€¢	Used for partial abstraction

â¸»

8. Constructor
   
	â€¢	Special method used to initialize objects
	â€¢	Same name as class
	â€¢	No return type

â¸»

9. Method Overloading vs Overriding
```
Feature	                 Overloading	    Overriding
Runtime/Compile time	 Compile-time	    Runtime
Parameters	             Different	      Same
Class relation	         Same class	      Parent-child
```

â¸»

â€œOOPS has four major pillars â€” Encapsulation, Abstraction, Inheritance, and Polymorphism.â€
Then explain each in one line, with example if required.


-------------

# âœ… Abstract Class vs Interface

Abstract Class

	â€¢	Can have abstract + concrete methods
	â€¢	Can have instance variables
	â€¢	Can have constructors
	â€¢	Single inheritance
	â€¢	Used when objects share common behavior + partial implementation

Example
```java
abstract class Animal {
    void eat() { System.out.println("Eating..."); }   // concrete method
    abstract void sound();                           // abstract method
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Bark");
    }
}
```

â¸»

Interface

	â€¢	Only abstract methods (until Java 8)
	â€¢	Can have default & static methods
	â€¢	Only public static final constants
	â€¢	No constructors
	â€¢	Supports multiple inheritance
	â€¢	Used when classes just need to follow a contract

Example
```java
interface Vehicle {
    void start();                 // implicitly abstract
}

class Car implements Vehicle {
    @Override
    public void start() {
        System.out.println("Car starting...");
    }
}
```

â¸»

ğŸ§  One-line memory trick

	â€¢	Interface = â€œWhat to doâ€ (no implementation).
	â€¢	Abstract class = â€œWhat + partial how to doâ€ (some implementation).

â¸»

# 4. Constants vs Enums

âœ… Enums vs Constants in Java

ğŸ‘‰ Constants are simple variable values with no enforcement or behavior.

ğŸ‘‰ Enums are powerful, type-safe, self-contained classes that represent a fixed set of related values.
â¸»

ğŸ” Practical Example (Why Enums are Better)

âŒ Using constants:
```java
public static final int PENDING = 0;
public static final int SUCCESS = 1;
public static final int FAILED = 2;

void process(int status) {
    if (status == SUCCESS) {
        ...
    }
}
```
If someone passes 5, code still compiles â†’ Not safe.

â¸»

âœ… Using enums:
```java
enum PaymentStatus {
    PENDING, SUCCESS, FAILED
}

void process(PaymentStatus status) {
    if (status == PaymentStatus.SUCCESS) {
        ...
    }
}
```
If someone passes anything else, the compiler rejects â†’ Safe.

â¸»

ğŸ”¥ Enums with Behavior

Enums are actually classes, so you can add logic.
```java
enum Direction {
    NORTH(0), SOUTH(180), EAST(90), WEST(270);

    private int angle;

    Direction(int angle) {
        this.angle = angle;
    }

    public int getAngle() {
        return angle;
    }
}
```

â¸»

ğŸ§  When to Use What?

âœ” Use ENUM when:

	â€¢	Values are fixed (states, directions, types)
	â€¢	You want type safety
	â€¢	You need to attach behavior
	â€¢	You want clean and readable domain models

âœ” Use CONSTANTS when:

	â€¢	Itâ€™s a simple number/string used rarely
	â€¢	Behavior is not required
	â€¢	No need to enforce fixed acceptable values

â¸»

Enums are preferred in modern Java for all domain-specific fixed categories.

â¸»


# Marker interface

A Marker Interface is an interface that has no methods and no fields.

It is used only to mark a class with some metadata so that JVM or frameworks treat that class differently.

Examples in Java

	â€¢	Serializable
	â€¢	Cloneable
	â€¢	Remote
	â€¢	RandomAccess

â¸»

â“ Why does Java use Marker Interfaces?

Because before annotations were introduced (Java 1.5), Java needed a way to mark classes with special behavior.

So marker interfaces are used to:
```
âœ” Identify that a class has a special property
âœ” Tell JVM or a library to enable some special logic
âœ” Give metadata at compile time
âœ” Enforce type safety (important!)
```
â¸»

ğŸ” Simple Example: Serializable
```java
class Student implements Serializable {
    private int id;
    private String name;
}
```
This tells Java:

â€œThis class can be converted to bytes.â€

If you donâ€™t implement Serializable and try to serialize it â†’ you get NotSerializableException.

â¸»

ğŸ§  How JVM uses Marker Interfaces?

Marker interfaces are checked using:
```java
if (obj instanceof Serializable) {
    // perform serialization
}
```
So the interface acts as a flag.

â¸»

# Java 8 features

ğŸš€ Introduction

Java 8 (released in 2014) introduced functional programming and stream processing, making Java more concise and expressive.
It was one of the biggest updates to Java since its creation.

â¸»

### ğŸ§  1. Lambda Expressions

Definition:

A lambda expression is a short block of code that takes parameters and returns a value â€” used to implement functional interfaces.

Syntax:

(parameters) -> { body }

Example:
```java
// Before Java 8
new Thread(new Runnable() {
    public void run() {
        System.out.println("Hello!");
    }
}).start();

// Java 8
new Thread(() -> System.out.println("Hello!")).start();
```
âœ… Benefits

	â€¢	Less boilerplate code
	â€¢	Improves readability
	â€¢	Enables functional-style programming

â¸»

### ğŸ§  2. Functional Interfaces

Definition:

A Functional Interface contains only one abstract method.
They can be implemented using lambda expressions.

##### Common Examples in Java
- `Runnable` (single `run()` method)
- `Callable` (single `call()` method)
- `Comparator` (single `compare()` method)
- Java 8 interfaces in `java.util.function` package like `Predicate<T>`, `Function<T, R>`, `Supplier<T>`, etc.

```java
interface Calculator {
    void switchOn();
}

//traditional way
public class Main implements Calculator{

    @Override
    public void switchOn() {
        System.out.println("Turned On");
    }

    public static void main(String args[]) {
        Main obj = new Main();
        obj.switchOn();
    }
}

//using lambda expression
public class Main{
    public static void main(String[] args) {
        //Calculator cal = () -> {System.out.println("Turned On");}
        Calculator cal = () -> System.out.println("Turned On");  //incase of only one statement, we don't need {}
        cal.switchOn();
    }
}
```

```java
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Kate", "Alex" , "Are");
//traditional way + 2
//        LengthComparator lc = new LengthComparator();
//
//        Collections.sort(names, lc);
//
//        System.out.println(names);

//using lambda, does not require tranditional way + 1 as well
        Collections.sort(names, (a,b) -> Integer.compare(a.length(),b.length()));
        System.out.println(names);
    }
}

//traditional way + 1
class LengthComparator implements Comparator<String> {

    @Override
    public int compare(String s1, String s2) {
        return Integer.compare(s1.length(),s2.length());
    }
}
```

##### Consumer, Predicate, and Supplier

Consumer, Predicate, and Supplier are some of the most commonly used.

These interfaces enable functional programming and are widely used with lambda expressions, Streams, and method references.

â¸»

#### ğŸ“¦ 1. Consumer<T>

âœ… Purpose:

Represents an operation that takes a single input and returns no result.

âœ… Functional Method:
```java
void accept(T t);
```
ğŸ§ª Example:
```java
import java.util.function.Consumer;
//traditional way
public class Main implements Consumer<Integer> {
    @Override
    public void accept(Integer i) {
        System.out.println("printing: " + i);
    }

    public static void main(String[] args) {
        Main obj = new Main();
        obj.accept(1);
    }

}

o/p: printing: 1

//lambda
public class Main {

    public static void main(String[] args) {
        Consumer<Integer> consumer = i -> System.out.println("printing: "+i);
        consumer.accept(1);
    }

}

o/p: printing: 1
```
#### Note: forEach() as takes consumer and internally uses accept() method
<img width="745" alt="Screenshot 2025-05-24 at 9 36 00â€¯PM" src="https://github.com/user-attachments/assets/31058168-4702-4044-9a46-57a1d8db9c04" />

eg:
```java
public class Main {

    public static void main(String[] args) {
//        Consumer<Integer> consumer = i -> System.out.println("printing: "+i);
//        consumer.accept(1);

        List<Integer> list = Arrays.asList(1,2,3,4);
        list.stream().forEach(i -> System.out.println("printing: "+i));
    }

}

o/p:
printing: 1
printing: 2
printing: 3
printing: 4
```

ğŸ“ Use Case:

	â€¢	Logging
	â€¢	Printing elements in a list
	â€¢	Performing side effects

â¸»

#### âœ… 2. Predicate<T>

âœ… Purpose:

Represents a boolean-valued function of one argument. Often used for filtering.

âœ… Functional Method:

boolean test(T t);

ğŸ§ª Example:
```java
//traditional way
public class Main implements Predicate<Integer> {
    @Override
    public boolean test(Integer integer) {
        return integer % 2 == 0;
    }

    public static void main(String[] args) {
        Main obj = new Main();
        System.out.println(obj.test(4)); //output: true
    }
}

//using lambda
public class Main {

    public static void main(String[] args) {
//        Predicate<Integer> predicate = i -> {
//            return i % 2 == 0;
//        };
        Predicate<Integer> predicate = i -> i%2 == 0;
        System.out.println(predicate.test(5)); //output: false

        //In Java lambda expressions, you can omit the return keyword and curly braces {}
        // when the lambda body contains only a single expression.
        // The expressionâ€™s value is automatically returned.
    }

}
```
#### Note: filter() method of streams accepts predicate as input and internally uses test method
<img width="774" alt="Screenshot 2025-05-24 at 10 10 18â€¯PM" src="https://github.com/user-attachments/assets/76e59110-08d1-4f4a-ae5c-9da5bafe2b0e" />

eg:
```java
public class Main {

    public static void main(String[] args) {

//        Predicate<Integer> predicate = i -> i%2 == 0;
//        System.out.println(predicate.test(5));

        List<Integer> input = Arrays.asList(1,2,3,4);
        input.stream().filter(i -> i%2 == 0)
                .forEach(i -> System.out.println("print even: " + i));

    }

}

output:
print even: 2
print even: 4
```
ğŸ“ Use Case:

	â€¢	Filtering collections
	â€¢	Conditional checks

â¸»

#### âœ… 3. Supplier<T>

âœ… Purpose:

Represents a supplier of results. Takes no input and returns a value.

âœ… Functional Method:

T get();

ğŸ§ª Example:

```java
//traditional way
public class Main implements Supplier<String> {

    @Override
    public String get() {
        return "hello";
    }

    public static void main(String[] args) {
        //Main obj = new Main();
        Supplier<String> supplier = new Main();
        System.out.println(supplier.get()); //output: hello
    }

}

//lambda
public class Main {

    public static void main(String[] args) {

        Supplier<String> supplier = () -> "hello";
        System.out.println(supplier.get()); //hello
    }
}

```

#### Note: orElseGet of streams internally accepts supplier and users get method
<img width="866" alt="Screenshot 2025-05-24 at 10 27 31â€¯PM" src="https://github.com/user-attachments/assets/4a0b745e-f197-4660-9eac-e1c736d43ffd" />

eg:
```java
public class Main {

    public static void main(String[] args) {

//        Supplier<String> supplier = () -> "hello";
//        System.out.println(supplier.get());

        List<String> list = Arrays.asList();
        System.out.println(list.stream().findAny().orElseGet(() -> "hey nothing found in the list"));

    }
}

output:
hey nothing found in the list
```
ğŸ“ Use Case:

	â€¢	Lazy initialization
	â€¢	Generating values or objects
	â€¢	Supplying default values

â¸»

### ğŸ§  3. Stream API - Definition, Intermediate & Terminal Functions


#### âœ… Stream API â€” Definition

The Stream API (introduced in Java 8) is a feature used to process data in a declarative, functional style.

A Stream:

	â€¢	Is a sequence of elements (like data from a list, set, or array)
	â€¢	Supports functional operations (map, filter, reduceâ€¦)
	â€¢	Does not store data â€” it only processes it
	â€¢	Is lazy â€” intermediate operations run only when a terminal operation is called
	â€¢	Can be parallel (for performance)

ğŸ’¡ Think of stream like a pipeline:

Data enters â†’ goes through operations â†’ gives output.

â¸»

âœ… Why Use Streams?

	â€¢	Less code
	â€¢	More readable
	â€¢	Functional operations
	â€¢	Easy transformations
	â€¢	Parallel processing support

â¸»

âœ… Stream API Pipeline Structure

A Stream pipeline has three parts:

	1.	Source (collection/array/IO data)
	2.	Intermediate operations (map/filter/sortedâ€¦)
	3.	Terminal operation (collect/forEach/reduceâ€¦)

â¸»

#### â­ 1) STREAM CREATION (Source)

Examples:
```java
Stream<Integer> stream = List.of(1, 2, 3).stream();
Stream<String> stream2 = Stream.of("a", "b", "c");
```

â¸»

#### â­ 2) INTERMEDIATE OPERATIONS

These operations return a Stream and are lazy.

They do not execute until a terminal operation is called.

Common Intermediate Operations:

1ï¸âƒ£ filter()

Filters data based on a condition.
```java
list.stream()
    .filter(n -> n % 2 == 0)
```
2ï¸âƒ£ map()

Transforms each element.
```java
list.stream()
    .map(n -> n * 2)
```
3ï¸âƒ£ flatMap()

Flattens nested structures.
```java
listOfLists.stream()
    .flatMap(List::stream)
```
4ï¸âƒ£ sorted()

Sorts elements.
```java
list.stream().sorted()
```
5ï¸âƒ£ distinct()

Removes duplicates.
```java
list.stream().distinct()
```
6ï¸âƒ£ limit() and skip()

Take or skip first N elements.
```java
list.stream().limit(3)
list.stream().skip(2)
```
7ï¸âƒ£ peek()

Debugging helper.
```java
list.stream().peek(System.out::println)
```

â¸»

#### â­ 3) TERMINAL OPERATIONS

These operations end the stream pipeline and produce a result

(either a single value, a collection, or a side effect).

Common Terminal Operations:

1ï¸âƒ£ forEach()

Iterates and performs action.
```java
list.stream().forEach(System.out::println);
```
2ï¸âƒ£ collect()

Converts stream â†’ list/set/map.
```java
List<Integer> result = list.stream()
        .filter(n -> n > 10)
        .collect(Collectors.toList());
```
3ï¸âƒ£ reduce()

Reduces elements to a single result.
```java
int sum = list.stream()
        .reduce(0, (a, b) -> a + b);
```
4ï¸âƒ£ count()

Counts elements.
```java
list.stream().count();
```
5ï¸âƒ£ min() / max()
```java
list.stream().max(Integer::compareTo);
```
6ï¸âƒ£ anyMatch / allMatch / noneMatch

Checks conditions.
```java
list.stream().anyMatch(n -> n > 10);
```
7ï¸âƒ£ findFirst / findAny
```java
list.stream().findFirst();
```

â¸»

ğŸ§  Example of Complete Stream Pipeline

Input: [1, 2, 3, 4, 5]

Task: Multiply even numbers by 10 and collect result.
```java
List<Integer> result = List.of(1,2,3,4,5).stream()
        .filter(n -> n % 2 == 0)    // intermediate
        .map(n -> n * 10)           // intermediate
        .collect(Collectors.toList()); // terminal
```
Output:

[20, 40]

â¸»

	â€¢	Stream is not a data structure, itâ€™s a data-processing pipeline.
	â€¢	Intermediate operations are lazy and return Stream.
	â€¢	Terminal operations trigger execution.
	â€¢	Streams can be parallel for performance.
	â€¢	A stream can be used only once (after terminal op itâ€™s closed).
	â€¢	Supports functional programming in Java.

â¸»

### ğŸ§  4. Default & Static Methods in Interfaces

Before Java 8:

	â€¢	Interfaces could only contain abstract methods.
	â€¢	Adding a new method to an interface broke all implementing classes.

Java 8 introduced:

	â€¢	default methods
	â€¢	static methods

to solve these issues and support functional programming.

â¸»

#### âœ… 1. DEFAULT METHODS

A default method is a method inside an interface that has a body (implementation).

âœ” Why default methods?

To add new methods to an interface without breaking existing implementations.

Example:
```java
interface Vehicle {
    void start();

    default void honk() {
        System.out.println("Honking...");
    }
}
```
âœ” Key Points:

	â€¢	A class inheriting the interface gets this method automatically.
	â€¢	Implementing class may override it â€” but not required.
	â€¢	Helps maintain backward compatibility.

âœ” Example Usage:
```java
class Car implements Vehicle {
    public void start() {
        System.out.println("Car started");
    }
}

public class Test {
    public static void main(String[] args) {
        Vehicle v = new Car();
        v.honk(); // default method
    }
}
```
â¸»

âš¡ When to Use Default Methods?

	â€¢	When you want to provide optional behavior.
	â€¢	When adding a method to an interface used by many classes (to avoid breaking them).
	â€¢	When providing reusable utility logic, but still allowing override.

â¸»

#### âœ… 2. STATIC METHODS IN INTERFACES

Static methods in interfaces are similar to static methods in classes â€” but they belong to the interface itself.

âœ” Why static methods?

To provide utility/helper methods related to the interface.

Example:
```java
interface MathUtils {
    static int add(int a, int b) {
        return a + b;
    }
}
```
âœ” How to call them?

int result = MathUtils.add(5, 10); 

âœ” Key Points:

	â€¢	Cannot be overridden by implementing classes.
	â€¢	Cannot be called using an object reference.
```java
MathUtils obj = new MathUtils(); // âŒ not allowed
obj.add(1,2);                   // âŒ not allowed
```

	â€¢	Must be called using interface name.

â¸»

ğŸ§  Simple Intuition

	â€¢	default â†’ â€œI will provide a default behavior; classes can use or override it.â€
	â€¢	static â†’ â€œThis is a helper function; it belongs to the interface class itself.â€


â¸»

#### âœ… What if your class implements two interfaces having the same default method?

This creates a diamond problem:
Both interfaces offer the same method signature + default implementation.

Example:
```java
interface A {
    default void hello() { System.out.println("Hello from A"); }
}

interface B {
    default void hello() { System.out.println("Hello from B"); }
}

class C implements A, B {
}
```

ğŸ‘‰ This does NOT compile.

Java doesnâ€™t know which default method to inherit.

â—Compiler Error:

class C inherits unrelated defaults for hello() from A and B


â¸»

#### How to solve it?

You must override the method in your class and choose which interfaceâ€™s method you want.
```java
class C implements A, B {
    @Override
    public void hello() {
        A.super.hello(); // Calling Interface A's default method
        // OR
        // B.super.hello();
    }
}
```

â¸»

#### How to call the method in Interface A inside implementing class?

Use:
```java
A.super.methodName();
```
Example:
```java
class C implements A, B {
    @Override
    public void hello() {
        A.super.hello();   // Calls A's default method
    }
}
```

â¸»

#### Why canâ€™t you call a default method directly in main?

Because:

âœ” Default methods belong to objects, not to the interface type.

You must always call them through an instance, not via interface name.

Example (not allowed):
```java
A.hello();  // âŒ Compile error
```
Error:

Non-static method hello() cannot be referenced from a static context

âœ” Why?

Because default methods are essentially instance methods, added to the class that implements the interface.

âœ” Correct way:
```java
A obj = new C();
obj.hello();  // âœ” works
```

â¸»

Purpose	Add new behavior without breaking old code	Utility/helper methods

âœ” Two interfaces with same default method?

Implementing class must override and choose explicitly.

âœ” Call interface-specific default method?

InterfaceName.super.methodName();

âœ” Why you canâ€™t call default method from main using interface name?

Because default methods are instance methods, not static methods.

â¸»


### ğŸ§  5. Optional Class

Purpose:

To handle null values safely without NullPointerException.

Example:
```
		Optional<String> name = Optional.ofNullable(null);
		System.out.println(name.orElse("Default Name")); //Default Name
		name.ifPresent(System.out::println); // does not execute
		System.out.println(name.orElse("nothing"));  //nothing

        Optional<String> name = Optional.ofNullable("Kate");
        System.out.println(name.isPresent()); // true 

        System.out.println(name.orElse("nothing"));  //Kate

        name.ifPresent(System.out::println); //Kate
```
Common Methods:

	â€¢	isPresent() â†’ check value presence
	â€¢	orElse() â†’ provide default
	â€¢	ifPresent() â†’ run code if not null

âœ… Benefits

	â€¢	Null-safe code
	â€¢	Improves readability

â¸»

### ğŸ§  6. New Date and Time API (java.time)

Replaces Date and Calendar with immutable, thread-safe, and easy-to-use classes.

Example:
```
import java.time.*;

LocalDate today = LocalDate.now();
LocalDate birthday = LocalDate.of(2000, Month.JUNE, 15);

Period age = Period.between(birthday, today);
System.out.println("Age: " + age.getYears());
```
Main Classes:

	â€¢	LocalDate, LocalTime, LocalDateTime
	â€¢	Period, Duration
	â€¢	ZonedDateTime

âœ… Benefits

	â€¢	Easier to format and manipulate
	â€¢	Immutable and thread-safe

â¸»

### ğŸ§  7. Method References

Definition:

Shortcut for lambda expressions that call existing methods.

Example:
```java
List<String> names = Arrays.asList("Kate", "Yashwanth", "Arelli");

// Lambda
names.forEach(n -> System.out.println(n));

// Method reference
names.forEach(System.out::println);
```
Types of References:

	â€¢	Class::staticMethod
	â€¢	object::instanceMethod
	â€¢	Class::new (constructor reference)

â¸»

### ğŸ§  8. Parallel Streams

Definition:

Runs stream operations in multiple threads to increase performance on large data sets.

Example:
```java
List<Integer> numbers = IntStream.rangeClosed(1, 1000000)
                                 .boxed()
                                 .collect(Collectors.toList());

long sum = numbers.parallelStream()
                  .mapToLong(i -> i)
                  .sum();

System.out.println(sum);
```
âš ï¸ Use carefully:

Parallel processing overhead can reduce performance for small datasets.

â¸»

ğŸ§¾ Summary Table

Feature					Purpose											Example
Lambda					Write concise code								(x) -> x * 2
Functional Interface	Enable lambdas									@FunctionalInterface
Stream API				Process collections easily						stream().filter()
Default/Static Methods	Extend interfaces								default void print()
Optional				Handle nulls safely								Optional.ofNullable()
Date & Time API			Modern date handling							LocalDate.now()
Method Reference		Simplify lambdas								System.out::println
Parallel Streams		Multi-threaded data ops							parallelStream()
Nashorn	Run JavaScript	engine.eval("JS")

â¸»

# 2. Exception Hierarchy
```
java.lang.Object
     â†“
  Throwable
   â”œâ”€â”€ Error (unchecked)
   â”‚      â”œâ”€â”€ OutOfMemoryError
   â”‚      â”œâ”€â”€ StackOverflowError
   â”‚      â””â”€â”€ etc...
   â””â”€â”€ Exception
          â”œâ”€â”€ RuntimeException (unchecked)
          â”‚       â”œâ”€â”€ NullPointerException
          â”‚       â”œâ”€â”€ ArithmeticException
          â”‚       â”œâ”€â”€ IllegalArgumentException
          â”‚       â””â”€â”€ ArrayIndexOutOfBoundsException
          â””â”€â”€ Checked Exceptions
                  â”œâ”€â”€ IOException
                  â”œâ”€â”€ SQLException
                  â”œâ”€â”€ ParseException
                  â””â”€â”€ ClassNotFoundException
```

- Exception hierarchy starts from Throwable class.

- Throwable has two children: Error and Exception.

- Errors are unrecoverable and represent issues outside application control.

- Exceptions are recoverable and divided into 

1. Checked exceptions (must be handled) 

These are exceptions that the compiler forces you to handle.

You MUST either:

	â€¢	use try-catch
	â€¢	or throws in method signature

Examples:

	â€¢	IOException
	â€¢	SQLException
	â€¢	FileNotFoundException
	â€¢	ClassNotFoundException


2. Unchecked exceptions (RuntimeException).

These happen during execution due to programming errors. Compiler does NOT force you to catch them.

Examples:

	â€¢	NullPointerException
	â€¢	ArithmeticException
	â€¢	ArrayIndexOutOfBoundsException
	â€¢	IllegalArgumentException
	â€¢	ClassCastException


â¸»

â­ 1. try

The try block contains code that might throw an exception.
```java
try {
    riskyCode();
}
```
Purpose:

âœ” Detect errors at runtime
âœ” Prevent application crash
âœ” Transfer control to a catch/finally block

â¸»

â­ 2. catch

The catch block handles the exception thrown inside the try block.
```java
catch(Exception e) {
    System.out.println(e.getMessage());
}
```
Purpose:

âœ” Handle the error
âœ” Recover or show meaningful message
âœ” Log the issue

You can have:

	â€¢	Multiple catch blocks
	â€¢	Catching specific exceptions first (most specific â†’ most general)

â¸»

â­ 3. finally

The finally block executes always, whether exception occurs or not.
```java
finally {
    closeResources();
}
```
Runs in:
âœ” Normal execution
âœ” Exception thrown
âœ” Exception handled
âœ” Exception not handled
âœ” Even after return statement inside try/catch

Purpose:
âœ” Clean-up code
âœ” Closing files/DB connections
âœ” Releasing resources

â¸»

â­ 4. throw

throw is used to explicitly throw an exception inside code.

throw new IllegalArgumentException("Invalid input");

Uses:

	â€¢	For custom validations
	â€¢	Manual exceptions
	â€¢	Business rule violations

Example:
```java
if(age < 18) {
    throw new RuntimeException("Not allowed");
}
```

â¸»

â­ 5. throws

throws is used in method declaration to say:

â€œThis method may throw an exception â€” caller must handle it.â€
```java
void readFile() throws IOException {
    // risky code
}
```
It does not throw exception.

It just declares the possibility.

Used mainly for:

âœ” Checked exceptions
âœ” Declaring contract for caller

â¸»

## Custom Exceptions

A custom exception is a user-defined exception that helps represent business-specific errors more clearly.
We create custom checked exceptions by extending Exception and custom unchecked exceptions by extending RuntimeException.â€


A custom exception is an exception you define yourself when Javaâ€™s built-in exceptions are not enough for your business logic.

For example:

	â€¢	â€œInsufficientBalanceExceptionâ€
	â€¢	â€œInvalidAgeExceptionâ€
	â€¢	â€œUnauthorizedUserExceptionâ€
	â€¢	â€œOrderNotFoundExceptionâ€

They make your code more meaningful, readable, and domain-specific.

â¸»

ğŸŸ¦ Types of Custom Exceptions

You can create:

1ï¸âƒ£ Custom Checked Exceptions

Extend Exception.

2ï¸âƒ£ Custom Unchecked Exceptions

Extend RuntimeException.

â¸»

ğŸŸ¦ 1. Custom Checked Exception

ğŸ‘‰ Use when caller must handle the exception

(either try-catch or throws)

Example: InvalidAgeException
```java
class InvalidAgeException extends Exception {
    public InvalidAgeException(String message) {
        super(message);
    }
}

//Use it:

public void register(int age) throws InvalidAgeException {
    if (age < 18) {
        throw new InvalidAgeException("Age must be 18 or above");
    }
}
```

â¸»

ğŸŸ© 2. Custom Unchecked Exception

ğŸ‘‰ Use when the exception is caused by programming errors

(no need to force try-catch)

Extend RuntimeException.
```java
class InsufficientBalanceException extends RuntimeException {
    public InsufficientBalanceException(String message) {
        super(message);
    }
}

//Use it:

public void withdraw(double amount) {
    if (amount > balance) {
        throw new InsufficientBalanceException("Not enough balance");
    }
}
```

â¸»

ğŸŸ§ Checked vs Unchecked Custom Exceptions
```
Type Extend			Must be caught?		When to use
Checked	Exception	Yes (compile-time)	Expected business rule failures
Unchecked			RuntimeException	No	Code bugs, invalid input, illegal states
```

â¸»

## Why do we need to use super(message); in custom exceptions?


Because Exception, RuntimeException, and Throwable (the parent classes) already have a constructor that accepts an error message.

Example from Java source:
```java
public Throwable(String message) {
    this.detailMessage = message;
}
```
So when you write:

super(message);

You are sending your custom message up to the parent class, so that:

âœ” The exception stores the message

âœ” The message appears in the logs

âœ” getMessage() returns your message

âœ” Stack trace shows helpful information

â¸»

ğŸŸ¦ Without super(message) â€” the exception message becomes NULL

Example:
```
class MyException extends RuntimeException {
    public MyException() {
        // NO super(message)
    }
}
```
Using it:
```java
throw new MyException("Something went wrong");
```
Output:
```
MyException: null
```
âŒ No message
âŒ Hard to debug
âŒ Useless in logs and monitoring

â¸»

ğŸŸ© With super(message) â€” message is preserved
```java
class MyException extends RuntimeException {
    public MyException(String message) {
        super(message);
    }
}
```
Now:
```java
throw new MyException("Something went wrong");
```
Output:
```
MyException: Something went wrong
```
âœ” Message is visible
âœ” Debugging becomes easy
âœ” Logs become meaningful

â¸»

We use super(message) to pass our custom error message to the parent Exception class. This allows the exception to store the message, display it in the stack trace, and retrieve it through getMessage(). Without it, the message will be lost.

â¸»

ğŸ”¥ Bonus: super(cause) and super(message, cause)

Exception classes allow:
```java
super(cause);           // chain exception
super(message, cause);  // message + root cause
```
These help track real underlying failures.

---------------

# 3. try-with-resources

try-with-resources is a Java feature that automatically closes resources (like files, DB connections, sockets, streams) after their usage â€” without requiring a finally block.

A resource is anything that implements the interface:

AutoCloseable


â¸»

ğŸš« Old way (before Java 7): Manual closing

Using a file:
```java
BufferedReader br = null;
try {
    br = new BufferedReader(new FileReader("data.txt"));
    System.out.println(br.readLine());
} catch (IOException e) {
    e.printStackTrace();
} finally {
    try {
        if (br != null) br.close();   // must close manually
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```
Problems:

âŒ Long code
âŒ Easy to forget closing
âŒ Possible memory/resource leaks

â¸»

âœ… New way (after Java 7): try-with-resources
```java
try (BufferedReader br = new BufferedReader(new FileReader("data.txt"))) {
    System.out.println(br.readLine());
} catch (IOException e) {
    e.printStackTrace();
}
```
Advantages:

âœ” Resource automatically closed
âœ” No need for finally block
âœ” Cleaner code
âœ” Prevents resource leaks
âœ” More readable

â¸»

ğŸ§  How it works internally?

At the end of the try block, Java automatically calls:
```java
br.close();
``
* because BufferedReader implements:
```
public interface Closeable extends AutoCloseable
```
* So anything implementing AutoCloseable works with try-with-resources.

â¸»

â€œTry-with-resources is a Java feature that automatically closes resources at the end of a try block. Any class implementing AutoCloseable can be used. This avoids memory leaks and makes code cleaner compared to the old try-catch-finally approach.â€

â¸»

â­ Extra imp Points

1. Resources are closed in reverse order

Last opened â†’ closed first.

2. Works with custom resources

You can create your own class:
```java
class MyResource implements AutoCloseable {
    @Override
    public void close() {
        System.out.println("Closed automatically");
    }
}
```
Then:
```java
try (MyResource r = new MyResource()) {
    // use resource
}
```
3. Finally block is not required

4. Less error-prone â†’ prevents resource leaks

â¸»

### Controller Advice, Rest Controller Advice, Exception Handler


ğŸŒŸ 1. @ControllerAdvice

âœ” What is it?

@ControllerAdvice is a global exception-handling mechanism in Spring MVC.

Think of it as a central place where:

	â€¢	You handle exceptions for all controllers
	â€¢	You write common error-handling logic
	â€¢	You avoid repeating try/catch in every controller

âœ” Key Point:

It works for:

	â€¢	@Controller
	â€¢	@RestController

âœ” Example:
```java
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(NullPointerException.class)
    public String handleNullPointer(NullPointerException ex) {
        return "error-page";   // returns view name
    }
}
```
ğŸ’¡ @ControllerAdvice is usually used in MVC apps that return views (HTML/JSP).

â¸»

ğŸŒŸ 2. @RestControllerAdvice

âœ” What is it?

@RestControllerAdvice = @ControllerAdvice + @ResponseBody

Meaning:

	â€¢	Returns JSON responses
	â€¢	Used in REST APIs

âœ” Example:
```java
@RestControllerAdvice
public class RestGlobalExceptionHandler {

    @ExceptionHandler(IllegalArgumentException.class)
    public ErrorResponse handleIllegalArgument(IllegalArgumentException ex) {

        return new ErrorResponse("INVALID_INPUT", ex.getMessage());
    }
}
```
ğŸ’¡ Use this in REST microservices built with Spring Boot.

â¸»

ğŸŒŸ 3. @ExceptionHandler

âœ” What is it?

@ExceptionHandler is used inside a Controller or inside ControllerAdvice to handle specific exceptions.

It tells Spring:

â€œWhenever this exception occurs, call this method.â€

âœ” Example inside @RestControllerAdvice:
```java
@ExceptionHandler(ResourceNotFoundException.class)
public ResponseEntity<?> handleResourceNotFound(ResourceNotFoundException ex) {
    return ResponseEntity.status(404).body(ex.getMessage());
}
```
âœ” It can handle:

	â€¢	One exception
	â€¢	Multiple exceptions
```java
@ExceptionHandler({NullPointerException.class, IllegalStateException.class})
```

â¸»

â­ How They Work Together (Big Picture)
```
Controller throws exception

â¬‡
Spring searches for local @ExceptionHandler
â¬‡
If not found â†’ checks @ControllerAdvice / @RestControllerAdvice
â¬‡
Returns response
```
â¸»

â­ Quick Summary Table
```
Annotation					Type			Used For						Returns	Best 		Use Case
@ControllerAdvice			Global			MVC Controllers					View (HTML)			Web apps
@RestControllerAdvice		Global			REST Controllers				JSON				REST APIs / Microservices
@ExceptionHandler			Local or Global	Handling specific exceptions	View or JSON		Business exceptions
```

â¸»

ğŸŒŸ Full Working Example (REST API)

ğŸ¯ Controller
```java
@RestController
public class UserController {

    @GetMapping("/user/{id}")
    public String getUser(@PathVariable int id) {
        if(id <= 0) {
            throw new IllegalArgumentException("Invalid user id");
        }
        return "User found";
    }
}
```

â¸»

ğŸ¯ Global Exception Handler
```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<String> handleIllegal(IllegalArgumentException ex) {
        return ResponseEntity.badRequest().body(ex.getMessage());
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleOther(Exception ex) {
        return ResponseEntity.status(500).body("Something went wrong");
    }
}
```

â¸»

ğŸŒŸ Output
```
Call: /user/-1
Response:

Invalid user id
```

â¸»
```
To avoid writing repetitive try/catch inside controllers.

It gives a common, centralized place to handle exceptions and improve code cleanliness.
```

â¸»


# Sealed Classes in Java

Sealed classes (introduced in Java 17) allow you to control which classes are allowed to extend or implement a class or interface.

Think of it like saying:

â€œOnly these specific subclasses are allowed. No one else can extend me.â€

This gives:

	â€¢	Better control over inheritance
	â€¢	More secure and predictable class hierarchies
	â€¢	Helps the compiler perform better exhaustiveness checks (like switch-expressions)

â¸»

âœ… Why do we need Sealed Classes?

Because normal inheritance is too open:

class A {}

Anyone can extend class A.

With sealed classes, you restrict this:

sealed class A permits B, C {}

Now only B and C can extend A.


â¸»

âœ… Syntax of Sealed Classes

1. Declaring a sealed class
```java
public sealed class Vehicle permits Car, Bike {}
```
2. Subclasses must choose exactly one of:
   
	â€¢	final â†’ cannot be extended further
	â€¢	sealed â†’ can further restrict its children
	â€¢	non-sealed â†’ open for extension

Example:
```java
public final class Car extends Vehicle {}        // no further extension allowed
public non-sealed class Bike extends Vehicle {}  // others can extend Bike
```
â¸»

âŒ Common Misconceptions

âŒ â€œSealed class means it cannot be extended.â€

No.

It can be extended â€” but only by permitted subclasses.

âŒ â€œSealed is same as final.â€

No.

final = no one can extend

sealed = some can extend

non-sealed = anyone can extend


A sealed class restricts which classes can extend or implement it. Its child classes must explicitly choose to be final, sealed, or non-sealed. It ensures controlled inheritance and helps the compiler with pattern matching.

â¸»

# Serialization vs Deserialization

ğŸŒŸ Serialization vs Deserialization (Simple Definition)
```
Concept				Meaning										Direction
Serialization		Converting a Java object â†’ byte stream		Object â Bytes
Deserialization		Converting a byte stream â†’ Java object		Bytes â Object
```

â¸»

ğŸŒŸ 1. What is Serialization?

Serialization is the process of converting a Java object into a byte stream so that it can be:

âœ” Saved to a file

âœ” Sent over a network

âœ” Stored in a database

âœ” Placed in cache (Redis, Kafka messages, etc.)

How to enable serialization?

A class must implement:
```java
class Employee implements Serializable {
    private String name;
    private int id;
}
```
Example:
```java
FileOutputStream fos = new FileOutputStream("data.ser");
ObjectOutputStream oos = new ObjectOutputStream(fos);

Employee e = new Employee("John", 101);
oos.writeObject(e);  // Serialization

oos.close();
```

â¸»

ğŸŒŸ 2. What is Deserialization?

Deserialization is converting the byte stream back into the original Java object.

Example:
```
FileInputStream fis = new FileInputStream("data.ser");
ObjectInputStream ois = new ObjectInputStream(fis);

Employee e = (Employee) ois.readObject();  // Deserialization

ois.close();
```

â¸»

Serialization is saving an object as bytes.

Deserialization is reconstructing the object from those bytes.

â¸»

ğŸŒŸ Real-World Examples

âœ” 1. REST APIs

Jackson automatically serializes Java objects â†’ JSON.

And deserializes JSON â†’ Java objects.

âœ” 2. Kafka messages

Producer serializes object â†’ bytes â†’ sends.

Consumer deserializes bytes â†’ object.

âœ” 3. Hibernate

Entities are serialized when going into cache (level 2 cache).

âœ” 4. Microservices

Objects shared between services over network are serialized as JSON/Avro.

â¸»

### ğŸ”¹ Why is Serialization needed?

Because objects cannot travel over network or be saved as they are. Only bytes can.

### ğŸ”¹ What happens if you donâ€™t implement Serializable?

NotSerializableException.

### ğŸ”¹ What is serialVersionUID?

A unique ID used for versioning during deserialization.

â¸»

ğŸŒŸ Final Comparison Table
```
Feature		Serialization				Deserialization
Purpose		Convert object â†’ bytes		Convert bytes â†’ object
Method		writeObject()				readObject()
Required 	Class						Implements Serializable	Same class must exist
Format		Binary or JSON/Avro/XML		Reconstructs original object
```

â¸»

## Transient

ğŸŒŸ What is transient in Java?

transient is a keyword used to indicate that a field should NOT be serialized.

Meaning:

ğŸ‘‰ When you convert an object â†’ bytes (Serialization),

transient fields are skipped and their values are not saved.

â¸»

ğŸŒŸ Why do we need transient?

Because some fields:

	â€¢	Should NOT be stored
	â€¢	Should NOT be sent across network
	â€¢	Are sensitive or temporary

Examples:

âœ” passwords
âœ” OTPs
âœ” cache-like values
âœ” large objects that shouldnâ€™t be serialized
âœ” computed values

â¸»

ğŸŒŸ Example
```java
class User implements Serializable {
    String username;
    transient String password;   // will NOT be serialized
}
```
Serialization:
```java
User u = new User("Kate", "secret123");
oos.writeObject(u);
```
Deserialization:
```java
User u = (User) ois.readObject();
```
Output:

	â€¢	username: â€œKateâ€
	â€¢	password: null (because it was transient)

â¸»

ğŸŒŸ Important Points

###  1. transient only affects Serialization

Not encryption, not hiding â€” only Java serialization.

### 2. If a field is transient, during deserialization:

	â€¢	primitives â†’ get default values
	â€¢	int â†’ 0
	â€¢	boolean â†’ false
	â€¢	objects â†’ null

###âœ” 3. transient + static = always skipped

Static fields never belong to an object â†’ automatically not serialized.

###âœ” 4. Used in frameworks

	â€¢	Hibernate: avoids serializing lazy-loaded fields
	â€¢	Spring Boot: avoids serializing internal objects
	â€¢	Kafka: avoid serializing unnecessary fields

â¸»

ğŸŒŸ Real-World Example
```java
class Employee implements Serializable {
    private String name;
    private transient int pinCode; // sensitive
}
```
When sending Employee object through REST API, Kafka, Redis, or writing to file:

âœ” name is serialized

âŒ pinCode is not serialized

â¸»

Summary

transient is a keyword used to tell Java not to serialize that field.
During serialization it is ignored; during deserialization it becomes default value (null/0/false).
It is used for sensitive, temporary, or unnecessary fields.

â¸»


# Shallow vs Deep Copy

ğŸŒŸ What is Shallow Copy?

A shallow copy copies only the top-level object,
NOT the nested (referenced) objects.

That means:

	â€¢	Primitive fields â†’ copied
	â€¢	Object fields â†’ only reference copied
	
(both original and copied objects point to same inner object)

âœ” Effects:

Changing inner object in copy will affect the original.

âœ” Example (Shallow Copy):
```
class Address {
    String city;
}

class Person implements Cloneable {
    String name;
    Address address;

    public Person clone() throws CloneNotSupportedException {
        return (Person) super.clone();  // shallow copy
    }
}
```
Usage:
```
Person p1 = new Person();
p1.name = "Kate";
p1.address = new Address();
p1.address.city = "Hyderabad";

Person p2 = p1.clone();

p2.address.city = "Mumbai";  
```
Result:
```
	â€¢	p1.address.city â†’ â€œMumbaiâ€
	â€¢	p2.address.city â†’ â€œMumbaiâ€
```
Because both share same Address object.

â¸»

ğŸŒŸ What is Deep Copy?

A deep copy copies:

	â€¢	the top-level object
	â€¢	AND all nested (reference) objects recursively

Deep copy = Completely independent object.

âœ” Effects:

Changing inner object in copy does not affect original.

âœ” Example (Deep Copy):
```java
class Address {
    String city;

    public Address(Address address) {
        this.city = address.city;  // copy values
    }
}

class Person implements Cloneable {
    String name;
    Address address;

    public Person clone() {
        Person copy = new Person();
        copy.name = this.name;
        copy.address = new Address(this.address); // deep copy
        return copy;
    }
}
```
Usage:
```java
Person p1 = new Person();
p1.name = "Kate";
p1.address = new Address();
p1.address.city = "Hyderabad";

Person p2 = p1.clone(); // deep

p2.address.city = "Mumbai";
```

Result:
```
	â€¢	p1.address.city â†’ â€œHyderabadâ€
	â€¢	p2.address.city â†’ â€œMumbaiâ€
```
They have separate Address objects.

â¸»

ğŸŒŸ Simple Explanation

Shallow copy copies only the object but not the objects referenced inside it.
Both original and copied object share same inner objects.

Deep copy copies everything including nested objects, so the copy is fully independent.

â¸»

ğŸŒŸ Comparison Table
```
Feature					Shallow Copy						Deep Copy
Top-level object		âœ” Copied							âœ” Copied
Nested objects			âŒ Not copied (shared)				âœ” Copied (new objects)
Performance				Faster								Slower
Independence			Not independent						Fully independent
Clone type				super.clone()						Manual cloning of nested objects
```

â¸»

# Fail-Fast vs Fail-Safe

1. Fail-Fast Iterator

A fail-fast iterator immediately throws an exception if the underlying collection is structurally modified while iterating.

ğŸ”¥ Example collections (fail-fast)

	â€¢	ArrayList
	â€¢	HashMap
	â€¢	LinkedList
	â€¢	HashSet
	â€¢	Vector (iterator)
	â€¢	Most collections from java.util package

ğŸ”¥ Behavior

If the collection is modified (add/remove) during iteration:

ğŸ‘‰ ConcurrentModificationException is thrown.

âœ” Why?

Fail-fast iterators use a variable called modCount.

Every structural modification changes the modCount.

Iterator compares expectedModCount with modCount. If mismatch â†’ throw exception.

â¸»

âŒ Fail-Fast Example
```java
List<String> list = new ArrayList<>();
list.add("A");
list.add("B");
list.add("C");

for (String s : list) {          // iterator internally
    list.add("D");               // modification during iteration
}
```
ğŸ‘‰ This throws ConcurrentModificationException.

â¸»

2. Fail-Safe Iterator

Fail-safe iterators do NOT throw exceptions if the collection is modified during iteration.

ğŸ”¥ Example collections (fail-safe)

Collections from java.util.concurrent package:

	â€¢	CopyOnWriteArrayList
	â€¢	ConcurrentHashMap
	â€¢	ConcurrentSkipListMap
	â€¢	ConcurrentSkipListSet

ğŸ”¥ Behavior

Fail-safe iterators work on a clone (copy) of the collection.

ğŸ‘‰ Modifying the original collection does not affect the iterator.
ğŸ‘‰ No ConcurrentModificationException.

â¸»

âœ” Fail-Safe Example
```java
CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
list.add("A");
list.add("B");
list.add("C");

for (String s : list) {
    list.add("D");   // allowed
}
```
ğŸ‘‰ No exception.
ğŸ‘‰ Iterator reads old snapshot; new values appear after iteration ends.

â¸»

ğŸ”¥ Key Differences
```
Feature								Fail-Fast										Fail-Safe
Behavior on modification			Throws ConcurrentModificationException			No exception
Works on							Actual collection								Copy (snapshot)
Memory usage						Low												High (copy created)
Speed								Faster											Slower
Example collections					ArrayList, HashMap, HashSet						CopyOnWriteArrayList, ConcurrentHashMap
Thread-safety						Not thread-safe									Thread-safe
Iterator type						Fail-fast iterator								Snapshot iterator
```

â¸»

ğŸ§  Why do they exist?

Fail-Fast

	â€¢	Detect inconsistent modifications quickly.
	â€¢	Prevents unpredictable behavior.

Fail-Safe

	â€¢	Useful for concurrent environments.
	â€¢	Allows iteration while modifications happen.

â¸»

ğŸ¯ Summary

Fail-fast iterators throw ConcurrentModificationException if the collection is structurally modified during iteration because they work on the actual collection. Fail-safe iterators do not throw exceptions because they work on a cloned snapshot of the collection. Fail-safe is used in concurrent collections, while fail-fast is used in regular collections.


â¸»

### Reentrant Lock

A ReentrantLock is a lock with the ability to be acquired multiple times by the same thread without causing a deadlock.

If a thread owns the lock, it can enter the same lock-protected code block again without blocking itself.

Each acquisition must be released the same number of times.

It is part of java.util.concurrent.locks.

â¸»

ğŸ”¹ Why use ReentrantLock instead of synchronized?
```
Feature					synchronized	ReentrantLock
Lock acquisition		Implicit		Explicit (lock() / unlock())
Fairness				No control		Can be fair (FIFO)
Try lock					âŒ			âœ… tryLock() avoids blocking
Interruptible				âŒ			âœ… lockInterruptibly()
```

â¸»

ğŸ”¹ Key Properties

	â€¢	Reentrant: Same thread can acquire the lock multiple times
	â€¢	Explicit unlock: Must call unlock() in finally block
	â€¢	Fairness: Optional FIFO ordering

â¸»

ğŸ”¹ Example
```java
import java.util.concurrent.locks.ReentrantLock;

public class Counter {
    private int count = 0;
    private final ReentrantLock lock = new ReentrantLock();

    public void increment() {
        lock.lock(); // acquire lock
        try {
            count++;
            // even if we call increment again in the same thread, it won't deadlock
        } finally {
            lock.unlock(); // release lock
        }
    }

    public int getCount() {
        return count;
    }
}

Using tryLock() (non-blocking)

if(lock.tryLock()) {
    try {
        // do work
    } finally {
        lock.unlock();
    }
} else {
    // lock not acquired, do something else
}
```

â¸»

ğŸ”¹ Key Points to Remember

	1.	Reentrant = same thread can acquire multiple times
	2.	Manual control vs synchronized
	3.	Supports advanced features: tryLock(), lockInterruptibly(), fairness
	4.	Always unlock in finally block to avoid deadlocks

â¸»

### Future vs Completable Future

ğŸ”¹ 1. Future

	â€¢	Introduced in Java 5 (java.util.concurrent.Future).
	â€¢	Represents the result of an asynchronous computation.
	â€¢	Can get the result using get(), which blocks the thread until the computation is done.
	â€¢	Cannot easily chain multiple tasks or handle callbacks without extra boilerplate.
	â€¢	Cannot be completed manually.

Example
```java
ExecutorService executor = Executors.newFixedThreadPool(1);

Future<Integer> future = executor.submit(() -> {
    Thread.sleep(1000);
    return 10;
});

System.out.println(future.get()); // blocks until result is ready
executor.shutdown();
```
Limitations of Future:

	â€¢	Blocking get()
	â€¢	No easy way to chain tasks (thenApply)
	â€¢	Cannot complete manually (only by executor)

â¸»

ğŸ”¹ 2. CompletableFuture

	â€¢	Introduced in Java 8 (java.util.concurrent.CompletableFuture).
	â€¢	Extends Future with non-blocking, async capabilities.
	â€¢	Supports:
	â€¢	Chaining (thenApply, thenAccept)
	â€¢	Combining multiple futures (thenCombine, allOf, anyOf)
	â€¢	Exception handling (exceptionally, handle)
	â€¢	Can be completed manually using complete().

Example
```java
public static void main(String[] args) {
    CompletableFuture<Integer> cf = CompletableFuture.supplyAsync(() -> {
        try { Thread.sleep(1000); } catch (InterruptedException e) {}
        return 20;
    });

    cf.thenApply(result -> result * 2)
      .thenAccept(result -> System.out.println("Result: " + result));

    System.out.println("Main thread continues working...");

    // No .get(), so main thread is not blocked
}
```
Output:
```
Main thread continues working...
Result: 40   <-- printed after 1 sec by another thread
```
â¸»
