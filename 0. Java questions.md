# 1. OOPs

There are four main pillars of OOPS:

	1.	Encapsulation
	2.	Abstraction
	3.	Inheritance
	4.	Polymorphism

Iâ€™ll explain each the way you should speak in an interview + small Java examples.

â¸»

â­ 1. Encapsulation

Encapsulation means wrapping data and methods into a single unit (a class) and restricting direct access to the data using access modifiers.

It protects data from unintended modifications.

Simple Example
```java
class BankAccount {
    private double balance; // hidden data

    public void deposit(double amount) {
        balance += amount;
    }

    public double getBalance() {
        return balance;
    }
}
```
ğŸ‘‰ balance is private â†’ cannot access directly â†’ controlled using getter/setter.

ğŸ¯ Key point to mention: â€œEncapsulation ensures data protection.â€

	â€¢	Data lives inside the class
	â€¢	Only methods inside the class can modify it

This is literally the meaning of encapsulation:

â€œWrapping data + methods together as one unitâ€

â¸»

â­ 2. Abstraction

Abstraction means showing only the essential details and hiding unnecessary internal complexity.

Example
```java
abstract class Payment {
    abstract void pay();
}

class CreditCardPayment extends Payment {
    void pay() {
        System.out.println("Payment done using credit card");
    }
}
```

```java
Payment payment = new CreditCardSystem();
payment.pay();
```
You donâ€™t need to know how the credit card works internally.

ğŸ¯ Key point: â€œAbstraction reduces complexity and focuses on what an object does, not how it does it.â€

Think of it as:
ğŸ‘‰ â€œI give you the function, but I hide the internal mechanics.â€

You only see the idea of paying, not the details

â¸»

â­ 3. Inheritance

Inheritance allows one class (child/subclass) to acquire properties and methods of another class (parent/superclass).

It promotes code reusability.

Example
```java
class Animal {
    void eat() {
        System.out.println("Animal eats");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("Dog barks");
    }
}
```
ğŸ‘‰ Dog gets eat() method without writing it again.
ğŸ¯ Key point: â€œInheritance helps with reusability and hierarchical relationships.â€

â¸»

â­ 4. Polymorphism

Polymorphism means same method name, different behavior.

There are two types:

	â€¢	Compile-time polymorphism â†’ Method Overloading
	â€¢	Runtime polymorphism â†’ Method Overriding

â¸»

Compile-time Polymorphism (Overloading)
```java
class Calculator {
    int add(int a, int b) { return a+b; }
    int add(int a, int b, int c) { return a+b+c; }
}
```

â¸»

Runtime Polymorphism (Overriding)
```java
class Animal {
    void sound() { System.out.println("Animal makes sound"); }
}

class Dog extends Animal {
    @Override
    void sound() { System.out.println("Dog barks"); }
}
```
ğŸ¯ Key point: â€œPolymorphism provides flexibility to use one interface with multiple implementations.â€

â¸»

ğŸ”¥ Bonus: Additional OOPS Concepts Interviewers Ask

5. Class vs Object
   
	â€¢	Class â†’ Blueprint
	â€¢	Object â†’ Instance of class

â¸»

6. Interface
   
	â€¢	100% abstraction (before Java 8)
	â€¢	Can have default and static methods
```java
interface Vehicle {
    void start();
}
```

â¸»

7. Abstract Class
   
	â€¢	Cannot be instantiated
	â€¢	Can contain abstract + concrete methods
	â€¢	Used for partial abstraction

â¸»

8. Constructor
   
	â€¢	Special method used to initialize objects
	â€¢	Same name as class
	â€¢	No return type

â¸»

9. Method Overloading vs Overriding
```
Feature	                 Overloading	    Overriding
Runtime/Compile time	 Compile-time	    Runtime
Parameters	             Different	      Same
Class relation	         Same class	      Parent-child
```

â¸»

â€œOOPS has four major pillars â€” Encapsulation, Abstraction, Inheritance, and Polymorphism.â€
Then explain each in one line, with example if required.


-------------

# âœ… Abstract Class vs Interface

Abstract Class

	â€¢	Can have abstract + concrete methods
	â€¢	Can have instance variables
	â€¢	Can have constructors
	â€¢	Single inheritance
	â€¢	Used when objects share common behavior + partial implementation

Example
```java
abstract class Animal {
    void eat() { System.out.println("Eating..."); }   // concrete method
    abstract void sound();                           // abstract method
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Bark");
    }
}
```

â¸»

Interface

	â€¢	Only abstract methods (until Java 8)
	â€¢	Can have default & static methods
	â€¢	Only public static final constants
	â€¢	No constructors
	â€¢	Supports multiple inheritance
	â€¢	Used when classes just need to follow a contract

Example
```java
interface Vehicle {
    void start();                 // implicitly abstract
}

class Car implements Vehicle {
    @Override
    public void start() {
        System.out.println("Car starting...");
    }
}
```

â¸»

ğŸ§  One-line memory trick

	â€¢	Interface = â€œWhat to doâ€ (no implementation).
	â€¢	Abstract class = â€œWhat + partial how to doâ€ (some implementation).

â¸»

# Sealed Classes in Java

Sealed classes (introduced in Java 17) allow you to control which classes are allowed to extend or implement a class or interface.

Think of it like saying:

â€œOnly these specific subclasses are allowed. No one else can extend me.â€

This gives:

	â€¢	Better control over inheritance
	â€¢	More secure and predictable class hierarchies
	â€¢	Helps the compiler perform better exhaustiveness checks (like switch-expressions)

â¸»

âœ… Why do we need Sealed Classes?

Because normal inheritance is too open:

class A {}

Anyone can extend class A.
With sealed classes, you restrict this:

sealed class A permits B, C {}

Now only B and C can extend A.


â¸»

âœ… Syntax of Sealed Classes

1. Declaring a sealed class
```java
public sealed class Vehicle permits Car, Bike {}
```
2. Subclasses must choose exactly one of:
   
	â€¢	final â†’ cannot be extended further
	â€¢	sealed â†’ can further restrict its children
	â€¢	non-sealed â†’ open for extension

Example:
```java
public final class Car extends Vehicle {}        // no further extension allowed
public non-sealed class Bike extends Vehicle {}  // others can extend Bike
```
â¸»

âŒ Common Misconceptions

âŒ â€œSealed class means it cannot be extended.â€

No.
It can be extended â€” but only by permitted subclasses.

âŒ â€œSealed is same as final.â€

No.
final = no one can extend
sealed = some can extend
non-sealed = anyone can extend


A sealed class restricts which classes can extend or implement it. Its child classes must explicitly choose to be final, sealed, or non-sealed. It ensures controlled inheritance and helps the compiler with pattern matching.

â¸»

# Marker interface

A Marker Interface is an interface that has no methods and no fields.

It is used only to mark a class with some metadata so that JVM or frameworks treat that class differently.

Examples in Java

	â€¢	Serializable
	â€¢	Cloneable
	â€¢	Remote
	â€¢	RandomAccess

â¸»

â“ Why does Java use Marker Interfaces?

Because before annotations were introduced (Java 1.5), Java needed a way to mark classes with special behavior.

So marker interfaces are used to:
```
âœ” Identify that a class has a special property
âœ” Tell JVM or a library to enable some special logic
âœ” Give metadata at compile time
âœ” Enforce type safety (important!)
```
â¸»

ğŸ” Simple Example: Serializable
```java
class Student implements Serializable {
    private int id;
    private String name;
}
```
This tells Java:

â€œThis class can be converted to bytes.â€

If you donâ€™t implement Serializable and try to serialize it â†’ you get NotSerializableException.

â¸»

ğŸ§  How JVM uses Marker Interfaces?

Marker interfaces are checked using:
```java
if (obj instanceof Serializable) {
    // perform serialization
}
```
So the interface acts as a flag.

â¸»

# Java 8 features

ğŸš€ Introduction

Java 8 (released in 2014) introduced functional programming and stream processing, making Java more concise and expressive.
It was one of the biggest updates to Java since its creation.

â¸»

### ğŸ§  1. Lambda Expressions

Definition:

A lambda expression is a short block of code that takes parameters and returns a value â€” used to implement functional interfaces.

Syntax:

(parameters) -> { body }

Example:
```java
// Before Java 8
new Thread(new Runnable() {
    public void run() {
        System.out.println("Hello!");
    }
}).start();

// Java 8
new Thread(() -> System.out.println("Hello!")).start();
```
âœ… Benefits

	â€¢	Less boilerplate code
	â€¢	Improves readability
	â€¢	Enables functional-style programming

â¸»

### ğŸ§  2. Functional Interfaces

Definition:

A Functional Interface contains only one abstract method.
They can be implemented using lambda expressions.

##### Common Examples in Java
- `Runnable` (single `run()` method)
- `Callable` (single `call()` method)
- `Comparator` (single `compare()` method)
- Java 8 interfaces in `java.util.function` package like `Predicate<T>`, `Function<T, R>`, `Supplier<T>`, etc.

```java
interface Calculator {
    void switchOn();
}

//traditional way
public class Main implements Calculator{

    @Override
    public void switchOn() {
        System.out.println("Turned On");
    }

    public static void main(String args[]) {
        Main obj = new Main();
        obj.switchOn();
    }
}

//using lambda expression
public class Main{
    public static void main(String[] args) {
        //Calculator cal = () -> {System.out.println("Turned On");}
        Calculator cal = () -> System.out.println("Turned On");  //incase of only one statement, we don't need {}
        cal.switchOn();
    }
}
```

```java
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Akshith", "Alex" , "Are");
//traditional way + 2
//        LengthComparator lc = new LengthComparator();
//
//        Collections.sort(names, lc);
//
//        System.out.println(names);

//using lambda, does not require tranditional way + 1 as well
        Collections.sort(names, (a,b) -> Integer.compare(a.length(),b.length()));
        System.out.println(names);
    }
}

//traditional way + 1
class LengthComparator implements Comparator<String> {

    @Override
    public int compare(String s1, String s2) {
        return Integer.compare(s1.length(),s2.length());
    }
}
```

##### Consumer, Predicate, and Supplier

Consumer, Predicate, and Supplier are some of the most commonly used.

These interfaces enable functional programming and are widely used with lambda expressions, Streams, and method references.

â¸»

##### ğŸ“¦ 1. Consumer<T>

âœ… Purpose:

Represents an operation that takes a single input and returns no result.

âœ… Functional Method:
```java
void accept(T t);
```
ğŸ§ª Example:
```java
import java.util.function.Consumer;
//traditional way
public class Main implements Consumer<Integer> {
    @Override
    public void accept(Integer i) {
        System.out.println("printing: " + i);
    }

    public static void main(String[] args) {
        Main obj = new Main();
        obj.accept(1);
    }

}

o/p: printing: 1

//lambda
public class Main {

    public static void main(String[] args) {
        Consumer<Integer> consumer = i -> System.out.println("printing: "+i);
        consumer.accept(1);
    }

}

o/p: printing: 1
```
##### Note: forEach() as takes consumer and internally uses accept() method
<img width="745" alt="Screenshot 2025-05-24 at 9 36 00â€¯PM" src="https://github.com/user-attachments/assets/31058168-4702-4044-9a46-57a1d8db9c04" />

eg:
```java
public class Main {

    public static void main(String[] args) {
//        Consumer<Integer> consumer = i -> System.out.println("printing: "+i);
//        consumer.accept(1);

        List<Integer> list = Arrays.asList(1,2,3,4);
        list.stream().forEach(i -> System.out.println("printing: "+i));
    }

}

o/p:
printing: 1
printing: 2
printing: 3
printing: 4
```

ğŸ“ Use Case:

	â€¢	Logging
	â€¢	Printing elements in a list
	â€¢	Performing side effects

â¸»

##### âœ… 2. Predicate<T>

âœ… Purpose:

Represents a boolean-valued function of one argument. Often used for filtering.

âœ… Functional Method:

boolean test(T t);

ğŸ§ª Example:
```java
//traditional way
public class Main implements Predicate<Integer> {
    @Override
    public boolean test(Integer integer) {
        return integer % 2 == 0;
    }

    public static void main(String[] args) {
        Main obj = new Main();
        System.out.println(obj.test(4)); //output: true
    }
}

//using lambda
public class Main {

    public static void main(String[] args) {
//        Predicate<Integer> predicate = i -> {
//            return i % 2 == 0;
//        };
        Predicate<Integer> predicate = i -> i%2 == 0;
        System.out.println(predicate.test(5)); //output: false

        //In Java lambda expressions, you can omit the return keyword and curly braces {}
        // when the lambda body contains only a single expression.
        // The expressionâ€™s value is automatically returned.
    }

}
```
##### Note: filter() method of streams accepts predicate as input and internally uses test method
<img width="774" alt="Screenshot 2025-05-24 at 10 10 18â€¯PM" src="https://github.com/user-attachments/assets/76e59110-08d1-4f4a-ae5c-9da5bafe2b0e" />

eg:
```java
public class Main {

    public static void main(String[] args) {

//        Predicate<Integer> predicate = i -> i%2 == 0;
//        System.out.println(predicate.test(5));

        List<Integer> input = Arrays.asList(1,2,3,4);
        input.stream().filter(i -> i%2 == 0)
                .forEach(i -> System.out.println("print even: " + i));

    }

}

output:
print even: 2
print even: 4
```
ğŸ“ Use Case:

	â€¢	Filtering collections
	â€¢	Conditional checks

â¸»

##### âœ… 3. Supplier<T>

âœ… Purpose:

Represents a supplier of results. Takes no input and returns a value.

âœ… Functional Method:

T get();

ğŸ§ª Example:

```java
//traditional way
public class Main implements Supplier<String> {

    @Override
    public String get() {
        return "hello";
    }

    public static void main(String[] args) {
        //Main obj = new Main();
        Supplier<String> supplier = new Main();
        System.out.println(supplier.get()); //output: hello
    }

}

//lambda
public class Main {

    public static void main(String[] args) {

        Supplier<String> supplier = () -> "hello";
        System.out.println(supplier.get()); //hello
    }
}

```

##### Note: orElseGet of streams internally accepts supplier and users get method
<img width="866" alt="Screenshot 2025-05-24 at 10 27 31â€¯PM" src="https://github.com/user-attachments/assets/4a0b745e-f197-4660-9eac-e1c736d43ffd" />

eg:
```java
public class Main {

    public static void main(String[] args) {

//        Supplier<String> supplier = () -> "hello";
//        System.out.println(supplier.get());

        List<String> list = Arrays.asList();
        System.out.println(list.stream().findAny().orElseGet(() -> "hey nothing found in the list"));

    }
}

output:
hey nothing found in the list
```
ğŸ“ Use Case:

	â€¢	Lazy initialization
	â€¢	Generating values or objects
	â€¢	Supplying default values

â¸»

### ğŸ§  3. Stream API - Definition, Intermediate & Terminal Functions


#### âœ… Stream API â€” Definition

The Stream API (introduced in Java 8) is a feature used to process data in a declarative, functional style.

A Stream:

	â€¢	Is a sequence of elements (like data from a list, set, or array)
	â€¢	Supports functional operations (map, filter, reduceâ€¦)
	â€¢	Does not store data â€” it only processes it
	â€¢	Is lazy â€” intermediate operations run only when a terminal operation is called
	â€¢	Can be parallel (for performance)

ğŸ’¡ Think of stream like a pipeline:

Data enters â†’ goes through operations â†’ gives output.

â¸»

âœ… Why Use Streams?

	â€¢	Less code
	â€¢	More readable
	â€¢	Functional operations
	â€¢	Easy transformations
	â€¢	Parallel processing support

â¸»

âœ… Stream API Pipeline Structure

A Stream pipeline has three parts:

	1.	Source (collection/array/IO data)
	2.	Intermediate operations (map/filter/sortedâ€¦)
	3.	Terminal operation (collect/forEach/reduceâ€¦)

â¸»

#### â­ 1) STREAM CREATION (Source)

Examples:
```java
Stream<Integer> stream = List.of(1, 2, 3).stream();
Stream<String> stream2 = Stream.of("a", "b", "c");
```

â¸»

#### â­ 2) INTERMEDIATE OPERATIONS

These operations return a Stream and are lazy.

They do not execute until a terminal operation is called.

Common Intermediate Operations:

1ï¸âƒ£ filter()

Filters data based on a condition.
```java
list.stream()
    .filter(n -> n % 2 == 0)
```
2ï¸âƒ£ map()

Transforms each element.
```java
list.stream()
    .map(n -> n * 2)
```
3ï¸âƒ£ flatMap()

Flattens nested structures.
```java
listOfLists.stream()
    .flatMap(List::stream)
```
4ï¸âƒ£ sorted()

Sorts elements.
```java
list.stream().sorted()
```
5ï¸âƒ£ distinct()

Removes duplicates.
```java
list.stream().distinct()
```
6ï¸âƒ£ limit() and skip()

Take or skip first N elements.
```java
list.stream().limit(3)
list.stream().skip(2)
```
7ï¸âƒ£ peek()

Debugging helper.
```java
list.stream().peek(System.out::println)
```

â¸»

#### â­ 3) TERMINAL OPERATIONS

These operations end the stream pipeline and produce a result

(either a single value, a collection, or a side effect).

Common Terminal Operations:

1ï¸âƒ£ forEach()

Iterates and performs action.
```java
list.stream().forEach(System.out::println);
```
2ï¸âƒ£ collect()

Converts stream â†’ list/set/map.
```java
List<Integer> result = list.stream()
        .filter(n -> n > 10)
        .collect(Collectors.toList());
```
3ï¸âƒ£ reduce()

Reduces elements to a single result.
```java
int sum = list.stream()
        .reduce(0, (a, b) -> a + b);
```
4ï¸âƒ£ count()

Counts elements.
```java
list.stream().count();
```
5ï¸âƒ£ min() / max()
```java
list.stream().max(Integer::compareTo);
```
6ï¸âƒ£ anyMatch / allMatch / noneMatch

Checks conditions.
```java
list.stream().anyMatch(n -> n > 10);
```
7ï¸âƒ£ findFirst / findAny
```java
list.stream().findFirst();
```

â¸»

ğŸ§  Example of Complete Stream Pipeline

Input: [1, 2, 3, 4, 5]

Task: Multiply even numbers by 10 and collect result.
```java
List<Integer> result = List.of(1,2,3,4,5).stream()
        .filter(n -> n % 2 == 0)    // intermediate
        .map(n -> n * 10)           // intermediate
        .collect(Collectors.toList()); // terminal
```
Output:

[20, 40]

â¸»

ğŸ§  Key Points to Remember (Interview Notes)

	â€¢	Stream is not a data structure, itâ€™s a data-processing pipeline.
	â€¢	Intermediate operations are lazy and return Stream.
	â€¢	Terminal operations trigger execution.
	â€¢	Streams can be parallel for performance.
	â€¢	A stream can be used only once (after terminal op itâ€™s closed).
	â€¢	Supports functional programming in Java.

â¸»

### ğŸ§  4. Default & Static Methods in Interfaces

Before Java 8, adding a new method to an interface broke all implementing classes.
Now, interfaces can contain:

	â€¢	default methods (with body)
	â€¢	static methods

Example:
```java
interface Vehicle {
    void start();

    default void fuelType() {
        System.out.println("Petrol");
    }

    static void service() {
        System.out.println("Service every 6 months");
    }
}
```
âœ… Benefits

	â€¢	Backward compatibility
	â€¢	Interfaces can evolve without breaking old implementations

â¸»

### ğŸ§  5. Optional Class

Purpose:

To handle null values safely without NullPointerException.

Example:
```
Optional<String> name = Optional.ofNullable(null);
System.out.println(name.orElse("Default Name"));
```
Common Methods:

	â€¢	isPresent() â†’ check value presence
	â€¢	orElse() â†’ provide default
	â€¢	ifPresent() â†’ run code if not null

âœ… Benefits

	â€¢	Null-safe code
	â€¢	Improves readability

â¸»

### ğŸ§  6. New Date and Time API (java.time)

Replaces Date and Calendar with immutable, thread-safe, and easy-to-use classes.

Example:
```
import java.time.*;

LocalDate today = LocalDate.now();
LocalDate birthday = LocalDate.of(2000, Month.JUNE, 15);

Period age = Period.between(birthday, today);
System.out.println("Age: " + age.getYears());
```
Main Classes:

	â€¢	LocalDate, LocalTime, LocalDateTime
	â€¢	Period, Duration
	â€¢	ZonedDateTime

âœ… Benefits

	â€¢	Easier to format and manipulate
	â€¢	Immutable and thread-safe

â¸»

### ğŸ§  7. Method References

Definition:

Shortcut for lambda expressions that call existing methods.

Example:
```java
List<String> names = Arrays.asList("Akshith", "Yashwanth", "Arelli");

// Lambda
names.forEach(n -> System.out.println(n));

// Method reference
names.forEach(System.out::println);
```
Types of References:

	â€¢	Class::staticMethod
	â€¢	object::instanceMethod
	â€¢	Class::new (constructor reference)

â¸»

### ğŸ§  8. Parallel Streams

Definition:

Runs stream operations in multiple threads to increase performance on large data sets.

Example:
```java
List<Integer> numbers = IntStream.rangeClosed(1, 1000000)
                                 .boxed()
                                 .collect(Collectors.toList());

long sum = numbers.parallelStream()
                  .mapToLong(i -> i)
                  .sum();

System.out.println(sum);
```
âš ï¸ Use carefully:

Parallel processing overhead can reduce performance for small datasets.

â¸»

ğŸ§¾ Summary Table

Feature					Purpose											Example
Lambda					Write concise code								(x) -> x * 2
Functional Interface	Enable lambdas									@FunctionalInterface
Stream API				Process collections easily						stream().filter()
Default/Static Methods	Extend interfaces								default void print()
Optional				Handle nulls safely								Optional.ofNullable()
Date & Time API			Modern date handling							LocalDate.now()
Method Reference		Simplify lambdas								System.out::println
Parallel Streams		Multi-threaded data ops							parallelStream()
Nashorn	Run JavaScript	engine.eval("JS")

â¸»

# 2. Exception Hierarchy
```
java.lang.Object
     â†“
  Throwable
   â”œâ”€â”€ Error (unchecked)
   â”‚      â”œâ”€â”€ OutOfMemoryError
   â”‚      â”œâ”€â”€ StackOverflowError
   â”‚      â””â”€â”€ etc...
   â””â”€â”€ Exception
          â”œâ”€â”€ RuntimeException (unchecked)
          â”‚       â”œâ”€â”€ NullPointerException
          â”‚       â”œâ”€â”€ ArithmeticException
          â”‚       â”œâ”€â”€ IllegalArgumentException
          â”‚       â””â”€â”€ ArrayIndexOutOfBoundsException
          â””â”€â”€ Checked Exceptions
                  â”œâ”€â”€ IOException
                  â”œâ”€â”€ SQLException
                  â”œâ”€â”€ ParseException
                  â””â”€â”€ ClassNotFoundException
```

- Exception hierarchy starts from Throwable class.

- Throwable has two children: Error and Exception.

- Errors are unrecoverable and represent issues outside application control.

- Exceptions are recoverable and divided into 

1. Checked exceptions (must be handled) 

These are exceptions that the compiler forces you to handle.

You MUST either:

	â€¢	use try-catch
	â€¢	or throws in method signature

Examples:

	â€¢	IOException
	â€¢	SQLException
	â€¢	FileNotFoundException
	â€¢	ClassNotFoundException


2. Unchecked exceptions (RuntimeException).

These happen during execution due to programming errors. Compiler does NOT force you to catch them.

Examples:

	â€¢	NullPointerException
	â€¢	ArithmeticException
	â€¢	ArrayIndexOutOfBoundsException
	â€¢	IllegalArgumentException
	â€¢	ClassCastException

## Custom Exceptions

A custom exception is a user-defined exception that helps represent business-specific errors more clearly.
We create custom checked exceptions by extending Exception and custom unchecked exceptions by extending RuntimeException.â€


A custom exception is an exception you define yourself when Javaâ€™s built-in exceptions are not enough for your business logic.

For example:

	â€¢	â€œInsufficientBalanceExceptionâ€
	â€¢	â€œInvalidAgeExceptionâ€
	â€¢	â€œUnauthorizedUserExceptionâ€
	â€¢	â€œOrderNotFoundExceptionâ€

They make your code more meaningful, readable, and domain-specific.

â¸»

ğŸŸ¦ Types of Custom Exceptions

You can create:

1ï¸âƒ£ Custom Checked Exceptions

Extend Exception.

2ï¸âƒ£ Custom Unchecked Exceptions

Extend RuntimeException.

â¸»

ğŸŸ¦ 1. Custom Checked Exception

ğŸ‘‰ Use when caller must handle the exception

(either try-catch or throws)

Example: InvalidAgeException
```java
class InvalidAgeException extends Exception {
    public InvalidAgeException(String message) {
        super(message);
    }
}

//Use it:

public void register(int age) throws InvalidAgeException {
    if (age < 18) {
        throw new InvalidAgeException("Age must be 18 or above");
    }
}
```

â¸»

ğŸŸ© 2. Custom Unchecked Exception

ğŸ‘‰ Use when the exception is caused by programming errors

(no need to force try-catch)

Extend RuntimeException.
```java
class InsufficientBalanceException extends RuntimeException {
    public InsufficientBalanceException(String message) {
        super(message);
    }
}

//Use it:

public void withdraw(double amount) {
    if (amount > balance) {
        throw new InsufficientBalanceException("Not enough balance");
    }
}
```

â¸»

ğŸŸ§ Checked vs Unchecked Custom Exceptions
```
Type Extend			Must be caught?		When to use
Checked	Exception	Yes (compile-time)	Expected business rule failures
Unchecked			RuntimeException	No	Code bugs, invalid input, illegal states
```

â¸»

## Why do we need to use super(message); in custom exceptions?


Because Exception, RuntimeException, and Throwable (the parent classes) already have a constructor that accepts an error message.

Example from Java source:
```java
public Throwable(String message) {
    this.detailMessage = message;
}
```
So when you write:

super(message);

You are sending your custom message up to the parent class, so that:

âœ” The exception stores the message

âœ” The message appears in the logs

âœ” getMessage() returns your message

âœ” Stack trace shows helpful information

â¸»

ğŸŸ¦ Without super(message) â€” the exception message becomes NULL

Example:
```
class MyException extends RuntimeException {
    public MyException() {
        // NO super(message)
    }
}
```
Using it:
```java
throw new MyException("Something went wrong");
```
Output:
```
MyException: null
```
âŒ No message
âŒ Hard to debug
âŒ Useless in logs and monitoring

â¸»

ğŸŸ© With super(message) â€” message is preserved
```java
class MyException extends RuntimeException {
    public MyException(String message) {
        super(message);
    }
}
```
Now:
```java
throw new MyException("Something went wrong");
```
Output:
```
MyException: Something went wrong
```
âœ” Message is visible
âœ” Debugging becomes easy
âœ” Logs become meaningful

â¸»

ğŸ§  Interview-Friendly Explanation

We use super(message) to pass our custom error message to the parent Exception class. This allows the exception to store the message, display it in the stack trace, and retrieve it through getMessage(). Without it, the message will be lost.

â¸»

ğŸ”¥ Bonus: super(cause) and super(message, cause)

Exception classes allow:
```java
super(cause);           // chain exception
super(message, cause);  // message + root cause
```
These help track real underlying failures.

---------------

# 3. try-with-resources

try-with-resources is a Java feature that automatically closes resources (like files, DB connections, sockets, streams) after their usage â€” without requiring a finally block.

A resource is anything that implements the interface:

AutoCloseable


â¸»

ğŸš« Old way (before Java 7): Manual closing

Using a file:
```java
BufferedReader br = null;
try {
    br = new BufferedReader(new FileReader("data.txt"));
    System.out.println(br.readLine());
} catch (IOException e) {
    e.printStackTrace();
} finally {
    try {
        if (br != null) br.close();   // must close manually
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```
Problems:

âŒ Long code
âŒ Easy to forget closing
âŒ Possible memory/resource leaks

â¸»

âœ… New way (after Java 7): try-with-resources
```java
try (BufferedReader br = new BufferedReader(new FileReader("data.txt"))) {
    System.out.println(br.readLine());
} catch (IOException e) {
    e.printStackTrace();
}
```
Advantages:

âœ” Resource automatically closed
âœ” No need for finally block
âœ” Cleaner code
âœ” Prevents resource leaks
âœ” More readable

â¸»

ğŸ§  How it works internally?

At the end of the try block, Java automatically calls:
```java
br.close();
``
* because BufferedReader implements:
```
public interface Closeable extends AutoCloseable
```
* So anything implementing AutoCloseable works with try-with-resources.

â¸»

ğŸ¯ Interview-level Summary

â€œTry-with-resources is a Java feature that automatically closes resources at the end of a try block. Any class implementing AutoCloseable can be used. This avoids memory leaks and makes code cleaner compared to the old try-catch-finally approach.â€

â¸»

â­ Extra Points for Interviews

1. Resources are closed in reverse order

Last opened â†’ closed first.

2. Works with custom resources

You can create your own class:
```java
class MyResource implements AutoCloseable {
    @Override
    public void close() {
        System.out.println("Closed automatically");
    }
}
```
Then:
```java
try (MyResource r = new MyResource()) {
    // use resource
}
```
3. Finally block is not required

4. Less error-prone â†’ prevents resource leaks


------------------

# 4. Constants vs Enums

Here is a clear and interview-friendly explanation of Enums vs Constants in Java:

â¸»

âœ… Enums vs Constants in Java

ğŸ‘‰ Constants are simple variable values with no enforcement or behavior.

ğŸ‘‰ Enums are powerful, type-safe, self-contained classes that represent a fixed set of related values.
â¸»

ğŸ” Practical Example (Why Enums are Better)

âŒ Using constants:
```java
public static final int PENDING = 0;
public static final int SUCCESS = 1;
public static final int FAILED = 2;

void process(int status) {
    if (status == SUCCESS) {
        ...
    }
}
```
If someone passes 5, code still compiles â†’ Not safe.

â¸»

âœ… Using enums:
```java
enum PaymentStatus {
    PENDING, SUCCESS, FAILED
}

void process(PaymentStatus status) {
    if (status == PaymentStatus.SUCCESS) {
        ...
    }
}
```
If someone passes anything else, the compiler rejects â†’ Safe.

â¸»

ğŸ”¥ Enums with Behavior

Enums are actually classes, so you can add logic.
```java
enum Direction {
    NORTH(0), SOUTH(180), EAST(90), WEST(270);

    private int angle;

    Direction(int angle) {
        this.angle = angle;
    }

    public int getAngle() {
        return angle;
    }
}
```

â¸»

ğŸ§  When to Use What?

âœ” Use ENUM when:

	â€¢	Values are fixed (states, directions, types)
	â€¢	You want type safety
	â€¢	You need to attach behavior
	â€¢	You want clean and readable domain models

âœ” Use CONSTANTS when:

	â€¢	Itâ€™s a simple number/string used rarely
	â€¢	Behavior is not required
	â€¢	No need to enforce fixed acceptable values

â¸»

Enums are preferred in modern Java for all domain-specific fixed categories.

----------

# 5. Fail-Fast vs Fail-Safe

1. Fail-Fast Iterator

A fail-fast iterator immediately throws an exception if the underlying collection is structurally modified while iterating.

ğŸ”¥ Example collections (fail-fast)

	â€¢	ArrayList
	â€¢	HashMap
	â€¢	LinkedList
	â€¢	HashSet
	â€¢	Vector (iterator)
	â€¢	Most collections from java.util package

ğŸ”¥ Behavior

If the collection is modified (add/remove) during iteration:

ğŸ‘‰ ConcurrentModificationException is thrown.

âœ” Why?

Fail-fast iterators use a variable called modCount.

Every structural modification changes the modCount.

Iterator compares expectedModCount with modCount. If mismatch â†’ throw exception.

â¸»

âŒ Fail-Fast Example
```java
List<String> list = new ArrayList<>();
list.add("A");
list.add("B");
list.add("C");

for (String s : list) {          // iterator internally
    list.add("D");               // modification during iteration
}
```
ğŸ‘‰ This throws ConcurrentModificationException.

â¸»

2. Fail-Safe Iterator

Fail-safe iterators do NOT throw exceptions if the collection is modified during iteration.

ğŸ”¥ Example collections (fail-safe)

Collections from java.util.concurrent package:

	â€¢	CopyOnWriteArrayList
	â€¢	ConcurrentHashMap
	â€¢	ConcurrentSkipListMap
	â€¢	ConcurrentSkipListSet

ğŸ”¥ Behavior

Fail-safe iterators work on a clone (copy) of the collection.

ğŸ‘‰ Modifying the original collection does not affect the iterator.
ğŸ‘‰ No ConcurrentModificationException.

â¸»

âœ” Fail-Safe Example
```java
CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
list.add("A");
list.add("B");
list.add("C");

for (String s : list) {
    list.add("D");   // allowed
}
```
ğŸ‘‰ No exception.
ğŸ‘‰ Iterator reads old snapshot; new values appear after iteration ends.

â¸»

ğŸ”¥ Key Differences (Interview Table)
```
Feature								Fail-Fast										Fail-Safe
Behavior on modification			Throws ConcurrentModificationException			No exception
Works on							Actual collection								Copy (snapshot)
Memory usage						Low												High (copy created)
Speed								Faster											Slower
Example collections					ArrayList, HashMap, HashSet						CopyOnWriteArrayList, ConcurrentHashMap
Thread-safety						Not thread-safe									Thread-safe
Iterator type						Fail-fast iterator								Snapshot iterator
```

â¸»

ğŸ§  Why do they exist?

Fail-Fast

	â€¢	Detect inconsistent modifications quickly.
	â€¢	Prevents unpredictable behavior.

Fail-Safe

	â€¢	Useful for concurrent environments.
	â€¢	Allows iteration while modifications happen.

â¸»

ğŸ¯ Interview Summary (Best Answer)

Fail-fast iterators throw ConcurrentModificationException if the collection is structurally modified during iteration because they work on the actual collection. Fail-safe iterators do not throw exceptions because they work on a cloned snapshot of the collection. Fail-safe is used in concurrent collections, while fail-fast is used in regular collections.


â¸»

### Reentrant Lock

A ReentrantLock is a lock with the ability to be acquired multiple times by the same thread without causing a deadlock.

If a thread owns the lock, it can enter the same lock-protected code block again without blocking itself.

Each acquisition must be released the same number of times.

It is part of java.util.concurrent.locks.

â¸»

ğŸ”¹ Why use ReentrantLock instead of synchronized?
```
Feature					synchronized	ReentrantLock
Lock acquisition		Implicit		Explicit (lock() / unlock())
Fairness				No control		Can be fair (FIFO)
Try lock					âŒ			âœ… tryLock() avoids blocking
Interruptible				âŒ			âœ… lockInterruptibly()
```

â¸»

ğŸ”¹ Key Properties

	â€¢	Reentrant: Same thread can acquire the lock multiple times
	â€¢	Explicit unlock: Must call unlock() in finally block
	â€¢	Fairness: Optional FIFO ordering

â¸»

ğŸ”¹ Example
```java
import java.util.concurrent.locks.ReentrantLock;

public class Counter {
    private int count = 0;
    private final ReentrantLock lock = new ReentrantLock();

    public void increment() {
        lock.lock(); // acquire lock
        try {
            count++;
            // even if we call increment again in the same thread, it won't deadlock
        } finally {
            lock.unlock(); // release lock
        }
    }

    public int getCount() {
        return count;
    }
}

Using tryLock() (non-blocking)

if(lock.tryLock()) {
    try {
        // do work
    } finally {
        lock.unlock();
    }
} else {
    // lock not acquired, do something else
}
```

â¸»

ğŸ”¹ Key Points to Remember for Interviews

	1.	Reentrant = same thread can acquire multiple times
	2.	Manual control vs synchronized
	3.	Supports advanced features: tryLock(), lockInterruptibly(), fairness
	4.	Always unlock in finally block to avoid deadlocks

â¸»

### Future vs Completable Future

ğŸ”¹ 1. Future

	â€¢	Introduced in Java 5 (java.util.concurrent.Future).
	â€¢	Represents the result of an asynchronous computation.
	â€¢	Can get the result using get(), which blocks the thread until the computation is done.
	â€¢	Cannot easily chain multiple tasks or handle callbacks without extra boilerplate.
	â€¢	Cannot be completed manually.

Example
```java
ExecutorService executor = Executors.newFixedThreadPool(1);

Future<Integer> future = executor.submit(() -> {
    Thread.sleep(1000);
    return 10;
});

System.out.println(future.get()); // blocks until result is ready
executor.shutdown();
```
Limitations of Future:

	â€¢	Blocking get()
	â€¢	No easy way to chain tasks (thenApply)
	â€¢	Cannot complete manually (only by executor)

â¸»

ğŸ”¹ 2. CompletableFuture

	â€¢	Introduced in Java 8 (java.util.concurrent.CompletableFuture).
	â€¢	Extends Future with non-blocking, async capabilities.
	â€¢	Supports:
	â€¢	Chaining (thenApply, thenAccept)
	â€¢	Combining multiple futures (thenCombine, allOf, anyOf)
	â€¢	Exception handling (exceptionally, handle)
	â€¢	Can be completed manually using complete().

Example
```java
public static void main(String[] args) {
    CompletableFuture<Integer> cf = CompletableFuture.supplyAsync(() -> {
        try { Thread.sleep(1000); } catch (InterruptedException e) {}
        return 20;
    });

    cf.thenApply(result -> result * 2)
      .thenAccept(result -> System.out.println("Result: " + result));

    System.out.println("Main thread continues working...");

    // No .get(), so main thread is not blocked
}
```
Output:
```
Main thread continues working...
Result: 40   <-- printed after 1 sec by another thread
```
â¸»
