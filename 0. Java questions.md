# 1. OOPs

There are four main pillars of OOPS:

	1.	Encapsulation
	2.	Abstraction
	3.	Inheritance
	4.	Polymorphism

‚∏ª

‚≠ê 1. Encapsulation

Encapsulation means wrapping data and methods into a single unit (a class) and restricting direct access to the data using access modifiers.

It protects data from unintended modifications.

Simple Example
```java
class BankAccount {
    private double balance; // hidden data

    public void deposit(double amount) {
        balance += amount;
    }

    public double getBalance() {
        return balance;
    }
}
```
üëâ balance is private ‚Üí cannot access directly ‚Üí controlled using getter/setter.

üéØ Key point to mention: ‚ÄúEncapsulation ensures data protection.‚Äù

	‚Ä¢	Data lives inside the class
	‚Ä¢	Only methods inside the class can modify it

This is literally the meaning of encapsulation:

‚ÄúWrapping data + methods together as one unit‚Äù

‚∏ª

‚≠ê 2. Abstraction

Abstraction means showing only the essential details and hiding unnecessary internal complexity.

Example
```java
abstract class Payment {
    abstract void pay();
}

class CreditCardPayment extends Payment {
    void pay() {
        System.out.println("Payment done using credit card");
    }
}
```

```java
Payment payment = new CreditCardSystem();
payment.pay();
```
You don‚Äôt need to know how the credit card works internally.

üéØ Key point: ‚ÄúAbstraction reduces complexity and focuses on what an object does, not how it does it.‚Äù

Think of it as:
üëâ ‚ÄúI give you the function, but I hide the internal mechanics.‚Äù

You only see the idea of paying, not the details

‚∏ª

‚≠ê 3. Inheritance

Inheritance allows one class (child/subclass) to acquire properties and methods of another class (parent/superclass).

It promotes code reusability.

Example
```java
class Animal {
    void eat() {
        System.out.println("Animal eats");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("Dog barks");
    }
}
```
üëâ Dog gets eat() method without writing it again.
üéØ Key point: ‚ÄúInheritance helps with reusability and hierarchical relationships.‚Äù

‚∏ª

‚≠ê 4. Polymorphism

Polymorphism means same method name, different behavior.

There are two types:

	‚Ä¢	Compile-time polymorphism ‚Üí Method Overloading
	‚Ä¢	Runtime polymorphism ‚Üí Method Overriding

‚∏ª

Compile-time Polymorphism (Overloading)
```java
class Calculator {
    int add(int a, int b) { return a+b; }
    int add(int a, int b, int c) { return a+b+c; }
}
```

‚∏ª

Runtime Polymorphism (Overriding)
```java
class Animal {
    void sound() { System.out.println("Animal makes sound"); }
}

class Dog extends Animal {
    @Override
    void sound() { System.out.println("Dog barks"); }
}
```
üéØ Key point: ‚ÄúPolymorphism provides flexibility to use one interface with multiple implementations.‚Äù

‚∏ª
Extras:

5. Class vs Object
   
	‚Ä¢	Class ‚Üí Blueprint
	‚Ä¢	Object ‚Üí Instance of class

‚∏ª

6. Interface
   
	‚Ä¢	100% abstraction (before Java 8)
	‚Ä¢	Can have default and static methods

```java
interface Vehicle {
    void start();
}
```

‚∏ª

7. Abstract Class
   
	‚Ä¢	Cannot be instantiated
	‚Ä¢	Can contain abstract + concrete methods
	‚Ä¢	Used for partial abstraction

‚∏ª

8. Constructor
   
	‚Ä¢	Special method used to initialize objects
	‚Ä¢	Same name as class
	‚Ä¢	No return type

‚∏ª

9. Method Overloading vs Overriding
```
Feature	                 Overloading	    Overriding
Runtime/Compile time	 Compile-time	    Runtime
Parameters	             Different	      Same
Class relation	         Same class	      Parent-child
```

‚∏ª

‚ÄúOOPS has four major pillars ‚Äî Encapsulation, Abstraction, Inheritance, and Polymorphism.‚Äù
Then explain each in one line, with example if required.


-------------

# ‚úÖ Abstract Class vs Interface

Abstract Class

	‚Ä¢	Can have abstract + concrete methods
	‚Ä¢	Can have instance variables
	‚Ä¢	Can have constructors
	‚Ä¢	Single inheritance
	‚Ä¢	Used when objects share common behavior + partial implementation

Example
```java
abstract class Animal {
    void eat() { System.out.println("Eating..."); }   // concrete method
    abstract void sound();                           // abstract method
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Bark");
    }
}
```

‚∏ª

Interface

	‚Ä¢	Only abstract methods (until Java 8)
	‚Ä¢	Can have default & static methods
	‚Ä¢	Only public static final constants
	‚Ä¢	No constructors
	‚Ä¢	Supports multiple inheritance
	‚Ä¢	Used when classes just need to follow a contract

Example
```java
interface Vehicle {
    void start();                 // implicitly abstract
}

class Car implements Vehicle {
    @Override
    public void start() {
        System.out.println("Car starting...");
    }
}
```

‚∏ª

üß† One-line memory trick

	‚Ä¢	Interface = ‚ÄúWhat to do‚Äù (no implementation).
	‚Ä¢	Abstract class = ‚ÄúWhat + partial how to do‚Äù (some implementation).

‚∏ª

# 4. Constants vs Enums

‚úÖ Enums vs Constants in Java

üëâ Constants are simple variable values with no enforcement or behavior.

üëâ Enums are powerful, type-safe, self-contained classes that represent a fixed set of related values.
‚∏ª

üîç Practical Example (Why Enums are Better)

‚ùå Using constants:
```java
public static final int PENDING = 0;
public static final int SUCCESS = 1;
public static final int FAILED = 2;

void process(int status) {
    if (status == SUCCESS) {
        ...
    }
}
```
If someone passes 5, code still compiles ‚Üí Not safe.

‚∏ª

‚úÖ Using enums:
```java
enum PaymentStatus {
    PENDING, SUCCESS, FAILED
}

void process(PaymentStatus status) {
    if (status == PaymentStatus.SUCCESS) {
        ...
    }
}
```
If someone passes anything else, the compiler rejects ‚Üí Safe.

‚∏ª

üî• Enums with Behavior

Enums are actually classes, so you can add logic.
```java
enum Direction {
    NORTH(0), SOUTH(180), EAST(90), WEST(270);

    private int angle;

    Direction(int angle) {
        this.angle = angle;
    }

    public int getAngle() {
        return angle;
    }
}
```
‚∏ª


# Marker interface

A Marker Interface is an interface that has no methods and no fields.

It is used only to mark a class with some metadata so that JVM or frameworks treat that class differently.

Examples in Java

	‚Ä¢	Serializable
	‚Ä¢	Cloneable
	‚Ä¢	Remote
	‚Ä¢	RandomAccess

‚∏ª

marker interfaces are used to:
```
‚úî Identify that a class has a special property
‚úî Tell JVM or a library to enable some special logic
‚úî Give metadata at compile time
‚úî Enforce type safety (important!)
```
‚∏ª

üîç Simple Example: Serializable
```java
class Student implements Serializable {
    private int id;
    private String name;
}
```
This tells Java:

‚ÄúThis class can be converted to bytes.‚Äù

If you don‚Äôt implement Serializable and try to serialize it ‚Üí you get NotSerializableException.

‚∏ª

üß† How JVM uses Marker Interfaces?

Marker interfaces are checked using:
```java
if (obj instanceof Serializable) {
    // perform serialization
}
```
So the interface acts as a flag.

‚∏ª

# Java 8 features

üöÄ Introduction

Java 8 (released in 2014) introduced functional programming and stream processing, making Java more concise and expressive.
It was one of the biggest updates to Java since its creation.

‚∏ª

### üß† 1. Lambda Expressions

Definition:

A lambda expression is a short block of code that takes parameters and returns a value ‚Äî used to implement functional interfaces.

Syntax:

(parameters) -> { body }

Example:
```java
// Before Java 8
new Thread(new Runnable() {
    public void run() {
        System.out.println("Hello!");
    }
}).start();

// Java 8
new Thread(() -> System.out.println("Hello!")).start();
```
‚úÖ Benefits

	‚Ä¢	Less boilerplate code
	‚Ä¢	Improves readability
	‚Ä¢	Enables functional-style programming

‚∏ª

### üß† 2. Functional Interfaces

Definition:

A Functional Interface contains only one abstract method.
They can be implemented using lambda expressions.

##### Common Examples in Java

- `Runnable` (single `run()` method)
- `Callable` (single `call()` method)
- `Comparator` (single `compare()` method)
- Java 8 interfaces in `java.util.function` package like `Predicate<T>`, `Function<T, R>`, `Supplier<T>`, etc.

```java
interface Calculator {
    void switchOn();
}

//traditional way
public class Main implements Calculator{

    @Override
    public void switchOn() {
        System.out.println("Turned On");
    }

    public static void main(String args[]) {
        Main obj = new Main();
        obj.switchOn();
    }
}

//using lambda expression
public class Main{
    public static void main(String[] args) {
        //Calculator cal = () -> {System.out.println("Turned On");}
        Calculator cal = () -> System.out.println("Turned On");  //incase of only one statement, we don't need {}
        cal.switchOn();
    }
}
```

```java
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Kate", "Alex" , "Are");
//traditional way + 2
//        LengthComparator lc = new LengthComparator();
//
//        Collections.sort(names, lc);
//
//        System.out.println(names);

//using lambda, does not require tranditional way + 1 as well
        Collections.sort(names, (a,b) -> Integer.compare(a.length(),b.length()));
        System.out.println(names);
    }
}

//traditional way + 1
class LengthComparator implements Comparator<String> {

    @Override
    public int compare(String s1, String s2) {
        return Integer.compare(s1.length(),s2.length());
    }
}
```

##### Consumer, Predicate, and Supplier

Consumer, Predicate, and Supplier are some of the most commonly used.

These interfaces enable functional programming and are widely used with lambda expressions, Streams, and method references.

‚∏ª

#### üì¶ 1. Consumer<T>

‚úÖ Purpose:

Represents an operation that takes a single input and returns no result.

‚úÖ Functional Method:
```java
void accept(T t);
```
üß™ Example:
```java
import java.util.function.Consumer;
//traditional way
public class Main implements Consumer<Integer> {
    @Override
    public void accept(Integer i) {
        System.out.println("printing: " + i);
    }

    public static void main(String[] args) {
        Main obj = new Main();
        obj.accept(1);
    }

}

o/p: printing: 1

//lambda
public class Main {

    public static void main(String[] args) {
        Consumer<Integer> consumer = i -> System.out.println("printing: "+i);
        consumer.accept(1);
    }

}

o/p: printing: 1
```
#### Note: forEach() as takes consumer and internally uses accept() method
<img width="745" alt="Screenshot 2025-05-24 at 9 36 00‚ÄØPM" src="https://github.com/user-attachments/assets/31058168-4702-4044-9a46-57a1d8db9c04" />

eg:
```java
public class Main {

    public static void main(String[] args) {
//        Consumer<Integer> consumer = i -> System.out.println("printing: "+i);
//        consumer.accept(1);

        List<Integer> list = Arrays.asList(1,2,3,4);
        list.stream().forEach(i -> System.out.println("printing: "+i));
    }

}

o/p:
printing: 1
printing: 2
printing: 3
printing: 4
```

üìù Use Case:

	‚Ä¢	Logging
	‚Ä¢	Printing elements in a list
	‚Ä¢	Performing side effects

‚∏ª

#### ‚úÖ 2. Predicate<T>

‚úÖ Purpose:

Represents a boolean-valued function of one argument. Often used for filtering.

‚úÖ Functional Method:

boolean test(T t);

üß™ Example:
```java
//traditional way
public class Main implements Predicate<Integer> {
    @Override
    public boolean test(Integer integer) {
        return integer % 2 == 0;
    }

    public static void main(String[] args) {
        Main obj = new Main();
        System.out.println(obj.test(4)); //output: true
    }
}

//using lambda
public class Main {

    public static void main(String[] args) {
//        Predicate<Integer> predicate = i -> {
//            return i % 2 == 0;
//        };
        Predicate<Integer> predicate = i -> i%2 == 0;
        System.out.println(predicate.test(5)); //output: false

        //In Java lambda expressions, you can omit the return keyword and curly braces {}
        // when the lambda body contains only a single expression.
        // The expression‚Äôs value is automatically returned.
    }

}
```
#### Note: filter() method of streams accepts predicate as input and internally uses test method
<img width="774" alt="Screenshot 2025-05-24 at 10 10 18‚ÄØPM" src="https://github.com/user-attachments/assets/76e59110-08d1-4f4a-ae5c-9da5bafe2b0e" />

eg:
```java
public class Main {

    public static void main(String[] args) {

//        Predicate<Integer> predicate = i -> i%2 == 0;
//        System.out.println(predicate.test(5));

        List<Integer> input = Arrays.asList(1,2,3,4);
        input.stream().filter(i -> i%2 == 0)
                .forEach(i -> System.out.println("print even: " + i));

    }

}

output:
print even: 2
print even: 4
```
üìù Use Case:

	‚Ä¢	Filtering collections
	‚Ä¢	Conditional checks

‚∏ª

#### ‚úÖ 3. Supplier<T>

‚úÖ Purpose:

Represents a supplier of results. Takes no input and returns a value.

‚úÖ Functional Method:

T get();

üß™ Example:

```java
//traditional way
public class Main implements Supplier<String> {

    @Override
    public String get() {
        return "hello";
    }

    public static void main(String[] args) {
        //Main obj = new Main();
        Supplier<String> supplier = new Main();
        System.out.println(supplier.get()); //output: hello
    }

}

//lambda
public class Main {

    public static void main(String[] args) {

        Supplier<String> supplier = () -> "hello";
        System.out.println(supplier.get()); //hello
    }
}

```

#### Note: orElseGet of streams internally accepts supplier and users get method
<img width="866" alt="Screenshot 2025-05-24 at 10 27 31‚ÄØPM" src="https://github.com/user-attachments/assets/4a0b745e-f197-4660-9eac-e1c736d43ffd" />

eg:
```java
public class Main {

    public static void main(String[] args) {

//        Supplier<String> supplier = () -> "hello";
//        System.out.println(supplier.get());

        List<String> list = Arrays.asList();
        System.out.println(list.stream().findAny().orElseGet(() -> "hey nothing found in the list"));

    }
}

output:
hey nothing found in the list
```
üìù Use Case:

	‚Ä¢	Lazy initialization
	‚Ä¢	Generating values or objects
	‚Ä¢	Supplying default values

‚∏ª

### üß† 3. Stream API - Definition, Intermediate & Terminal Functions


#### ‚úÖ Stream API ‚Äî Definition

The Stream API (introduced in Java 8) is a feature used to process data in a declarative, functional style.

A Stream:

	‚Ä¢	Is a sequence of elements (like data from a list, set, or array)
	‚Ä¢	Supports functional operations (map, filter, reduce‚Ä¶)
	‚Ä¢	Does not store data ‚Äî it only processes it
	‚Ä¢	Is lazy ‚Äî intermediate operations run only when a terminal operation is called
	‚Ä¢	Can be parallel (for performance)

üí° Think of stream like a pipeline:

Data enters ‚Üí goes through operations ‚Üí gives output.

‚∏ª

‚úÖ Why Use Streams?

	‚Ä¢	Less code
	‚Ä¢	More readable
	‚Ä¢	Functional operations
	‚Ä¢	Easy transformations
	‚Ä¢	Parallel processing support

‚∏ª

‚úÖ Stream API Pipeline Structure

A Stream pipeline has three parts:

	1.	Source (collection/array/IO data)
	2.	Intermediate operations (map/filter/sorted‚Ä¶)
	3.	Terminal operation (collect/forEach/reduce‚Ä¶)

‚∏ª

#### ‚≠ê 1) STREAM CREATION (Source)

Examples:
```java
Stream<Integer> stream = List.of(1, 2, 3).stream();
Stream<String> stream2 = Stream.of("a", "b", "c");
```

‚∏ª

#### ‚≠ê 2) INTERMEDIATE OPERATIONS

These operations return a Stream and are lazy.

They do not execute until a terminal operation is called.

Common Intermediate Operations:

1Ô∏è‚É£ filter()

Filters data based on a condition.
```java
list.stream()
    .filter(n -> n % 2 == 0)
```
2Ô∏è‚É£ map()

Transforms each element.
```java
list.stream()
    .map(n -> n * 2)
```
3Ô∏è‚É£ flatMap()

Flattens nested structures.
```java
listOfLists.stream()
    .flatMap(List::stream)
```
4Ô∏è‚É£ sorted()

Sorts elements.
```java
list.stream().sorted()
```
5Ô∏è‚É£ distinct()

Removes duplicates.
```java
list.stream().distinct()
```
6Ô∏è‚É£ limit() and skip()

Take or skip first N elements.
```java
list.stream().limit(3)
list.stream().skip(2)
```
7Ô∏è‚É£ peek()

Debugging helper.
```java
list.stream().peek(System.out::println)
```

‚∏ª

#### ‚≠ê 3) TERMINAL OPERATIONS

These operations end the stream pipeline and produce a result

(either a single value, a collection, or a side effect).

Common Terminal Operations:

1Ô∏è‚É£ forEach()

Iterates and performs action.
```java
list.stream().forEach(System.out::println);
```
2Ô∏è‚É£ collect()

Converts stream ‚Üí list/set/map.
```java
List<Integer> result = list.stream()
        .filter(n -> n > 10)
        .collect(Collectors.toList());
```
3Ô∏è‚É£ reduce()

Reduces elements to a single result.
```java
int sum = list.stream()
        .reduce(0, (a, b) -> a + b);
```
4Ô∏è‚É£ count()

Counts elements.
```java
list.stream().count();
```
5Ô∏è‚É£ min() / max()
```java
list.stream().max(Integer::compareTo);
```
6Ô∏è‚É£ anyMatch / allMatch / noneMatch

Checks conditions.
```java
list.stream().anyMatch(n -> n > 10);
```
7Ô∏è‚É£ findFirst / findAny
```java
list.stream().findFirst();
```

‚∏ª

üß† Example of Complete Stream Pipeline

Input: [1, 2, 3, 4, 5]

Task: Multiply even numbers by 10 and collect result.
```java
List<Integer> result = List.of(1,2,3,4,5).stream()
        .filter(n -> n % 2 == 0)    // intermediate
        .map(n -> n * 10)           // intermediate
        .collect(Collectors.toList()); // terminal
```
Output:

[20, 40]

‚∏ª

	‚Ä¢	Stream is not a data structure, it‚Äôs a data-processing pipeline.
	‚Ä¢	Intermediate operations are lazy and return Stream.
	‚Ä¢	Terminal operations trigger execution.
	‚Ä¢	Streams can be parallel for performance.
	‚Ä¢	A stream can be used only once (after terminal op it‚Äôs closed).
	‚Ä¢	Supports functional programming in Java.

‚∏ª

### üß† 4. Default & Static Methods in Interfaces

Before Java 8:

	‚Ä¢	Interfaces could only contain abstract methods.
	‚Ä¢	Adding a new method to an interface broke all implementing classes.

Java 8 introduced:

	‚Ä¢	default methods
	‚Ä¢	static methods

to solve these issues and support functional programming.

‚∏ª

#### ‚úÖ 1. DEFAULT METHODS

A default method is a method inside an interface that has a body (implementation).

‚úî Why default methods?

To add new methods to an interface without breaking existing implementations.

Example:
```java
interface Vehicle {
    void start();

    default void honk() {
        System.out.println("Honking...");
    }
}
```
‚úî Key Points:

	‚Ä¢	A class inheriting the interface gets this method automatically.
	‚Ä¢	Implementing class may override it ‚Äî but not required.
	‚Ä¢	Helps maintain backward compatibility.

‚úî Example Usage:
```java
class Car implements Vehicle {
    public void start() {
        System.out.println("Car started");
    }
}

public class Test {
    public static void main(String[] args) {
        Vehicle v = new Car();
        v.honk(); // default method
    }
}
```
‚∏ª

‚ö° When to Use Default Methods?

	‚Ä¢	When you want to provide optional behavior.
	‚Ä¢	When adding a method to an interface used by many classes (to avoid breaking them).
	‚Ä¢	When providing reusable utility logic, but still allowing override.

‚∏ª

#### ‚úÖ 2. STATIC METHODS IN INTERFACES

Static methods in interfaces are similar to static methods in classes ‚Äî but they belong to the interface itself.

‚úî Why static methods?

To provide utility/helper methods related to the interface.

Example:
```java
interface MathUtils {
    static int add(int a, int b) {
        return a + b;
    }
}
```
‚úî How to call them?

int result = MathUtils.add(5, 10); 

‚úî Key Points:

	‚Ä¢	Cannot be overridden by implementing classes.
	‚Ä¢	Cannot be called using an object reference.
```java
MathUtils obj = new MathUtils(); // ‚ùå not allowed
obj.add(1,2);                   // ‚ùå not allowed
```

	‚Ä¢	Must be called using interface name.

‚∏ª

üß† Simple Intuition

	‚Ä¢	default ‚Üí ‚ÄúI will provide a default behavior; classes can use or override it.‚Äù
	‚Ä¢	static ‚Üí ‚ÄúThis is a helper function; it belongs to the interface class itself.‚Äù


‚∏ª

#### ‚úÖ What if your class implements two interfaces having the same default method?

This creates a diamond problem:
Both interfaces offer the same method signature + default implementation.

Example:
```java
interface A {
    default void hello() { System.out.println("Hello from A"); }
}

interface B {
    default void hello() { System.out.println("Hello from B"); }
}

class C implements A, B {
}
```

üëâ This does NOT compile.

Java doesn‚Äôt know which default method to inherit.

‚ùóCompiler Error:

class C inherits unrelated defaults for hello() from A and B


‚∏ª

#### How to solve it?

You must override the method in your class and choose which interface‚Äôs method you want.
```java
class C implements A, B {
    @Override
    public void hello() {
        A.super.hello(); // Calling Interface A's default method
        // OR
        // B.super.hello();
    }
}
```

‚∏ª

#### How to call the method in Interface A inside implementing class?

Use:
```java
A.super.methodName();
```
Example:
```java
class C implements A, B {
    @Override
    public void hello() {
        A.super.hello();   // Calls A's default method
    }
}
```

‚∏ª

#### Why can‚Äôt you call a default method directly in main?

Because:

‚úî Default methods belong to objects, not to the interface type.

You must always call them through an instance, not via interface name.

Example (not allowed):
```java
A.hello();  // ‚ùå Compile error
```
Error:

Non-static method hello() cannot be referenced from a static context

‚úî Why?

Because default methods are essentially instance methods, added to the class that implements the interface.

‚úî Correct way:
```java
A obj = new C();
obj.hello();  // ‚úî works
```

‚∏ª

Purpose	Add new behavior without breaking old code	Utility/helper methods

‚úî Two interfaces with same default method?

Implementing class must override and choose explicitly.

‚úî Call interface-specific default method?

InterfaceName.super.methodName();

‚úî Why you can‚Äôt call default method from main using interface name?

Because default methods are instance methods, not static methods.

‚∏ª


### üß† 5. Optional Class

Purpose:

To handle null values safely without NullPointerException.

Example:
```
		Optional<String> name = Optional.ofNullable(null);
		System.out.println(name.orElse("Default Name")); //Default Name
		name.ifPresent(System.out::println); // does not execute
		System.out.println(name.orElse("nothing"));  //nothing

        Optional<String> name = Optional.ofNullable("Kate");
        System.out.println(name.isPresent()); // true 

        System.out.println(name.orElse("nothing"));  //Kate

        name.ifPresent(System.out::println); //Kate
```
Common Methods:

	‚Ä¢	isPresent() ‚Üí check value presence
	‚Ä¢	orElse() ‚Üí provide default
	‚Ä¢	ifPresent() ‚Üí run code if not null

‚úÖ Benefits

	‚Ä¢	Null-safe code
	‚Ä¢	Improves readability

‚∏ª

### üß† 6. New Date and Time API (java.time)

Replaces Date and Calendar with immutable, thread-safe, and easy-to-use classes.

Example:
```
import java.time.*;

LocalDate today = LocalDate.now();
LocalDate birthday = LocalDate.of(2000, Month.JUNE, 15);

Period age = Period.between(birthday, today);
System.out.println("Age: " + age.getYears());
```
Main Classes:

	‚Ä¢	LocalDate, LocalTime, LocalDateTime
	‚Ä¢	Period, Duration
	‚Ä¢	ZonedDateTime

‚úÖ Benefits

	‚Ä¢	Easier to format and manipulate
	‚Ä¢	Immutable and thread-safe

‚∏ª

### üß† 7. Method References

Definition:

Shortcut for lambda expressions that call existing methods.

Example:
```java
List<String> names = Arrays.asList("Kate", "Yashwanth", "Arelli");

// Lambda
names.forEach(n -> System.out.println(n));

// Method reference
names.forEach(System.out::println);
```
Types of References:

	‚Ä¢	Class::staticMethod
	‚Ä¢	object::instanceMethod
	‚Ä¢	Class::new (constructor reference)

‚∏ª

### üß† 8. Parallel Streams

Definition:

Runs stream operations in multiple threads to increase performance on large data sets.

Example:
```java
List<Integer> numbers = IntStream.rangeClosed(1, 1000000)
                                 .boxed()
                                 .collect(Collectors.toList());

long sum = numbers.parallelStream()
                  .mapToLong(i -> i)
                  .sum();

System.out.println(sum);
```
‚ö†Ô∏è Use carefully:

Parallel processing overhead can reduce performance for small datasets.

‚∏ª

# 2. Exception Hierarchy
```
java.lang.Object
     ‚Üì
  Throwable
   ‚îú‚îÄ‚îÄ Error (unchecked)
   ‚îÇ      ‚îú‚îÄ‚îÄ OutOfMemoryError
   ‚îÇ      ‚îú‚îÄ‚îÄ StackOverflowError
   ‚îÇ      ‚îî‚îÄ‚îÄ etc...
   ‚îî‚îÄ‚îÄ Exception
          ‚îú‚îÄ‚îÄ RuntimeException (unchecked)
          ‚îÇ       ‚îú‚îÄ‚îÄ NullPointerException
          ‚îÇ       ‚îú‚îÄ‚îÄ ArithmeticException
          ‚îÇ       ‚îú‚îÄ‚îÄ IllegalArgumentException
          ‚îÇ       ‚îî‚îÄ‚îÄ ArrayIndexOutOfBoundsException
          ‚îî‚îÄ‚îÄ Checked Exceptions
                  ‚îú‚îÄ‚îÄ IOException
                  ‚îú‚îÄ‚îÄ SQLException
                  ‚îú‚îÄ‚îÄ ParseException
                  ‚îî‚îÄ‚îÄ ClassNotFoundException
```

- Exception hierarchy starts from Throwable class.

- Throwable has two children: Error and Exception.

- Errors are unrecoverable and represent issues outside application control.

- Exceptions are recoverable and divided into 

1. Checked exceptions (must be handled) 

These are exceptions that the compiler forces you to handle.

You MUST either:

	‚Ä¢	use try-catch
	‚Ä¢	or throws in method signature

Examples:

	‚Ä¢	IOException
	‚Ä¢	SQLException
	‚Ä¢	FileNotFoundException
	‚Ä¢	ClassNotFoundException


2. Unchecked exceptions (RuntimeException).

These happen during execution due to programming errors. Compiler does NOT force you to catch them.

Examples:

	‚Ä¢	NullPointerException
	‚Ä¢	ArithmeticException
	‚Ä¢	ArrayIndexOutOfBoundsException
	‚Ä¢	IllegalArgumentException
	‚Ä¢	ClassCastException


‚∏ª

‚≠ê 1. try

The try block contains code that might throw an exception.
```java
try {
    riskyCode();
}
```
Purpose:

‚úî Detect errors at runtime
‚úî Prevent application crash
‚úî Transfer control to a catch/finally block

‚∏ª

‚≠ê 2. catch

The catch block handles the exception thrown inside the try block.
```java
catch(Exception e) {
    System.out.println(e.getMessage());
}
```
Purpose:

‚úî Handle the error
‚úî Recover or show meaningful message
‚úî Log the issue

You can have:

	‚Ä¢	Multiple catch blocks
	‚Ä¢	Catching specific exceptions first (most specific ‚Üí most general)

‚∏ª

‚≠ê 3. finally

The finally block executes always, whether exception occurs or not.
```java
finally {
    closeResources();
}
```

‚∏ª

‚≠ê 4. throw

throw is used to explicitly throw an exception inside code.

throw new IllegalArgumentException("Invalid input");

Uses:

	‚Ä¢	For custom validations
	‚Ä¢	Manual exceptions
	‚Ä¢	Business rule violations

Example:
```java
if(age < 18) {
    throw new RuntimeException("Not allowed");
}
```

‚∏ª

‚≠ê 5. throws

throws is used in method declaration to say:

‚ÄúThis method may throw an exception ‚Äî caller must handle it.‚Äù
```java
void readFile() throws IOException {
    // risky code
}
```
It does not throw exception.

It just declares the possibility.

Used mainly for:

‚úî Checked exceptions
‚úî Declaring contract for caller

‚∏ª

## Custom Exceptions

A custom exception is a user-defined exception that helps represent business-specific errors more clearly.
We create custom checked exceptions by extending Exception and custom unchecked exceptions by extending RuntimeException.‚Äù


A custom exception is an exception you define yourself when Java‚Äôs built-in exceptions are not enough for your business logic.

For example:

	‚Ä¢	‚ÄúInsufficientBalanceException‚Äù
	‚Ä¢	‚ÄúInvalidAgeException‚Äù
	‚Ä¢	‚ÄúUnauthorizedUserException‚Äù
	‚Ä¢	‚ÄúOrderNotFoundException‚Äù

They make your code more meaningful, readable, and domain-specific.

‚∏ª

üü¶ Types of Custom Exceptions

You can create:

1Ô∏è‚É£ Custom Checked Exceptions

Extend Exception.

2Ô∏è‚É£ Custom Unchecked Exceptions

Extend RuntimeException.

‚∏ª

üü¶ 1. Custom Checked Exception

üëâ Use when caller must handle the exception

(either try-catch or throws)

Example: InvalidAgeException
```java
class InvalidAgeException extends Exception {
    public InvalidAgeException(String message) {
        super(message);
    }
}

//Use it:

public void register(int age) throws InvalidAgeException {
    if (age < 18) {
        throw new InvalidAgeException("Age must be 18 or above");
    }
}
```

‚∏ª

üü© 2. Custom Unchecked Exception

üëâ Use when the exception is caused by programming errors

(no need to force try-catch)

Extend RuntimeException.
```java
class InsufficientBalanceException extends RuntimeException {
    public InsufficientBalanceException(String message) {
        super(message);
    }
}

//Use it:

public void withdraw(double amount) {
    if (amount > balance) {
        throw new InsufficientBalanceException("Not enough balance");
    }
}
```

‚∏ª

üüß Checked vs Unchecked Custom Exceptions
```
Type Extend			Must be caught?		When to use
Checked	Exception	Yes (compile-time)	Expected business rule failures
Unchecked			RuntimeException	No	Code bugs, invalid input, illegal states
```

‚∏ª

## Why do we need to use super(message); in custom exceptions?


Because Exception, RuntimeException, and Throwable (the parent classes) already have a constructor that accepts an error message.

Example from Java source:
```java
public Throwable(String message) {
    this.detailMessage = message;
}
```
So when you write:

super(message);

You are sending your custom message up to the parent class, so that:

‚úî The exception stores the message

‚úî The message appears in the logs

‚úî getMessage() returns your message

‚úî Stack trace shows helpful information

‚∏ª

üü¶ Without super(message) ‚Äî the exception message becomes NULL

Example:
```
class MyException extends RuntimeException {
    public MyException() {
        // NO super(message)
    }
}
```
Using it:
```java
throw new MyException("Something went wrong");
```
Output:
```
MyException: null
```

‚ùå No message
‚ùå Hard to debug
‚ùå Useless in logs and monitoring

‚∏ª

üü© With super(message) ‚Äî message is preserved
```java
class MyException extends RuntimeException {
    public MyException(String message) {
        super(message);
    }
}
```
Now:
```java
throw new MyException("Something went wrong");
```
Output:
```
MyException: Something went wrong
```
‚úî Message is visible
‚úî Debugging becomes easy
‚úî Logs become meaningful

‚∏ª

We use super(message) to pass our custom error message to the parent Exception class. This allows the exception to store the message, display it in the stack trace, and retrieve it through getMessage(). Without it, the message will be lost.

‚∏ª

üî• Bonus: super(cause) and super(message, cause)

Exception classes allow:
```java
super(cause);           // chain exception
super(message, cause);  // message + root cause
```
These help track real underlying failures.

---------------

# 3. try-with-resources

try-with-resources is a Java feature that automatically closes resources (like files, DB connections, sockets, streams) after their usage ‚Äî without requiring a finally block.

A resource is anything that implements the interface:

AutoCloseable


‚∏ª

üö´ Old way (before Java 7): Manual closing

Using a file:
```java
BufferedReader br = null;
try {
    br = new BufferedReader(new FileReader("data.txt"));
    System.out.println(br.readLine());
} catch (IOException e) {
    e.printStackTrace();
} finally {
    try {
        if (br != null) br.close();   // must close manually
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```
Problems:

‚ùå Long code
‚ùå Easy to forget closing
‚ùå Possible memory/resource leaks

‚∏ª

‚úÖ New way (after Java 7): try-with-resources
```java
try (BufferedReader br = new BufferedReader(new FileReader("data.txt"))) {
    System.out.println(br.readLine());
} catch (IOException e) {
    e.printStackTrace();
}
```
Advantages:

‚úî Resource automatically closed
‚úî No need for finally block
‚úî Cleaner code
‚úî Prevents resource leaks
‚úî More readable

‚∏ª

üß† How it works internally?

At the end of the try block, Java automatically calls:
```java
br.close();
``
* because BufferedReader implements:
```
public interface Closeable extends AutoCloseable
```
* So anything implementing AutoCloseable works with try-with-resources.

‚∏ª

‚ÄúTry-with-resources is a Java feature that automatically closes resources at the end of a try block. Any class implementing AutoCloseable can be used. This avoids memory leaks and makes code cleaner compared to the old try-catch-finally approach.‚Äù

‚∏ª

‚≠ê Extra imp Points

1. Resources are closed in reverse order

Last opened ‚Üí closed first.

2. Works with custom resources

You can create your own class:
```java
class MyResource implements AutoCloseable {
    @Override
    public void close() {
        System.out.println("Closed automatically");
    }
}
```
Then:
```java
try (MyResource r = new MyResource()) {
    // use resource
}
```
3. Finally block is not required

4. Less error-prone ‚Üí prevents resource leaks

‚∏ª

### Controller Advice, Rest Controller Advice, Exception Handler


üåü 1. @ControllerAdvice

‚úî What is it?

@ControllerAdvice is a global exception-handling mechanism in Spring MVC.

Think of it as a central place where:

	‚Ä¢	You handle exceptions for all controllers
	‚Ä¢	You write common error-handling logic
	‚Ä¢	You avoid repeating try/catch in every controller

‚úî Key Point:

It works for:

	‚Ä¢	@Controller
	‚Ä¢	@RestController

‚úî Example:
```java
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(NullPointerException.class)
    public String handleNullPointer(NullPointerException ex) {
        return "error-page";   // returns view name
    }
}
```
üí° @ControllerAdvice is usually used in MVC apps that return views (HTML/JSP).

‚∏ª

üåü 2. @RestControllerAdvice

‚úî What is it?

@RestControllerAdvice = @ControllerAdvice + @ResponseBody

Meaning:

	‚Ä¢	Returns JSON responses
	‚Ä¢	Used in REST APIs

‚úî Example:
```java
@RestControllerAdvice
public class RestGlobalExceptionHandler {

    @ExceptionHandler(IllegalArgumentException.class)
    public ErrorResponse handleIllegalArgument(IllegalArgumentException ex) {

        return new ErrorResponse("INVALID_INPUT", ex.getMessage());
    }
}
```
üí° Use this in REST microservices built with Spring Boot.

‚∏ª

üåü 3. @ExceptionHandler

‚úî What is it?

@ExceptionHandler is used inside a Controller or inside ControllerAdvice to handle specific exceptions.

It tells Spring:

‚ÄúWhenever this exception occurs, call this method.‚Äù

‚úî Example inside @RestControllerAdvice:
```java
@ExceptionHandler(ResourceNotFoundException.class)
public ResponseEntity<?> handleResourceNotFound(ResourceNotFoundException ex) {
    return ResponseEntity.status(404).body(ex.getMessage());
}
```
‚úî It can handle:

	‚Ä¢	One exception
	‚Ä¢	Multiple exceptions
```java
@ExceptionHandler({NullPointerException.class, IllegalStateException.class})
```

‚∏ª

‚≠ê How They Work Together (Big Picture)
```
Controller throws exception

‚¨á
Spring searches for local @ExceptionHandler
‚¨á
If not found ‚Üí checks @ControllerAdvice / @RestControllerAdvice
‚¨á
Returns response
```
‚∏ª

‚≠ê Quick Summary Table
```
Annotation					Type			Used For						Returns	Best 		Use Case
@ControllerAdvice			Global			MVC Controllers					View (HTML)			Web apps
@RestControllerAdvice		Global			REST Controllers				JSON				REST APIs / Microservices
@ExceptionHandler			Local or Global	Handling specific exceptions	View or JSON		Business exceptions
```

‚∏ª

üåü Full Working Example (REST API)

üéØ Controller
```java
@RestController
public class UserController {

    @GetMapping("/user/{id}")
    public String getUser(@PathVariable int id) {
        if(id <= 0) {
            throw new IllegalArgumentException("Invalid user id");
        }
        return "User found";
    }
}
```

‚∏ª

üéØ Global Exception Handler
```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<String> handleIllegal(IllegalArgumentException ex) {
        return ResponseEntity.badRequest().body(ex.getMessage());
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleOther(Exception ex) {
        return ResponseEntity.status(500).body("Something went wrong");
    }
}
```

‚∏ª

üåü Output
```
Call: /user/-1
Response:

Invalid user id
```

‚∏ª
```
To avoid writing repetitive try/catch inside controllers.

It gives a common, centralized place to handle exceptions and improve code cleanliness.
```

‚∏ª


# Sealed Classes in Java

Sealed classes (introduced in Java 17) allow you to control which classes are allowed to extend or implement a class or interface.

Think of it like saying:

‚ÄúOnly these specific subclasses are allowed. No one else can extend me.‚Äù

This gives:

	‚Ä¢	Better control over inheritance
	‚Ä¢	More secure and predictable class hierarchies
	‚Ä¢	Helps the compiler perform better exhaustiveness checks (like switch-expressions)

‚∏ª

‚úÖ Why do we need Sealed Classes?

Because normal inheritance is too open:

class A {}

Anyone can extend class A.

With sealed classes, you restrict this:

sealed class A permits B, C {}

Now only B and C can extend A.


‚∏ª

‚úÖ Syntax of Sealed Classes

1. Declaring a sealed class
```java
public sealed class Vehicle permits Car, Bike {}
```
2. Subclasses must choose exactly one of:
   
	‚Ä¢	final ‚Üí cannot be extended further
	‚Ä¢	sealed ‚Üí can further restrict its children
	‚Ä¢	non-sealed ‚Üí open for extension

Example:
```java
public final class Car extends Vehicle {}        // no further extension allowed
public non-sealed class Bike extends Vehicle {}  // others can extend Bike
```
‚∏ª

‚ùå Common Misconceptions

‚ùå ‚ÄúSealed class means it cannot be extended.‚Äù

No.

It can be extended ‚Äî but only by permitted subclasses.

‚ùå ‚ÄúSealed is same as final.‚Äù

No.

final = no one can extend

sealed = some can extend

non-sealed = anyone can extend


A sealed class restricts which classes can extend or implement it. Its child classes must explicitly choose to be final, sealed, or non-sealed. It ensures controlled inheritance and helps the compiler with pattern matching.

‚∏ª

# Serialization vs Deserialization

üåü Serialization vs Deserialization (Simple Definition)
```
Concept				Meaning										Direction
Serialization		Converting a Java object ‚Üí byte stream		Object ‚ûù Bytes
Deserialization		Converting a byte stream ‚Üí Java object		Bytes ‚ûù Object
```

‚∏ª

üåü 1. What is Serialization?

Serialization is the process of converting a Java object into a byte stream so that it can be:

‚úî Saved to a file

‚úî Sent over a network

‚úî Stored in a database

‚úî Placed in cache (Redis, Kafka messages, etc.)

How to enable serialization?

A class must implement:
```java
class Employee implements Serializable {
    private String name;
    private int id;
}
```
Example:
```java
FileOutputStream fos = new FileOutputStream("data.ser");
ObjectOutputStream oos = new ObjectOutputStream(fos);

Employee e = new Employee("John", 101);
oos.writeObject(e);  // Serialization

oos.close();
```

‚∏ª

üåü 2. What is Deserialization?

Deserialization is converting the byte stream back into the original Java object.

Example:
```
FileInputStream fis = new FileInputStream("data.ser");
ObjectInputStream ois = new ObjectInputStream(fis);

Employee e = (Employee) ois.readObject();  // Deserialization

ois.close();
```

‚∏ª

Serialization is saving an object as bytes.

Deserialization is reconstructing the object from those bytes.

‚∏ª

üåü Real-World Examples

‚úî 1. REST APIs

Jackson automatically serializes Java objects ‚Üí JSON.

And deserializes JSON ‚Üí Java objects.

‚úî 2. Kafka messages

Producer serializes object ‚Üí bytes ‚Üí sends.

Consumer deserializes bytes ‚Üí object.

‚úî 3. Hibernate

Entities are serialized when going into cache (level 2 cache).

‚úî 4. Microservices

Objects shared between services over network are serialized as JSON/Avro.

‚∏ª

### üîπ Why is Serialization needed?

Because objects cannot travel over network or be saved as they are. Only bytes can.

### üîπ What happens if you don‚Äôt implement Serializable?

NotSerializableException.

### üîπ What is serialVersionUID?

A unique ID used for versioning during deserialization.

‚∏ª

## Transient

üåü What is transient in Java?

transient is a keyword used to indicate that a field should NOT be serialized.

Meaning:

üëâ When you convert an object ‚Üí bytes (Serialization),

transient fields are skipped and their values are not saved.

‚∏ª

üåü Why do we need transient?

Because some fields:

	‚Ä¢	Should NOT be stored
	‚Ä¢	Should NOT be sent across network
	‚Ä¢	Are sensitive or temporary

Examples:

‚úî passwords
‚úî OTPs
‚úî cache-like values
‚úî large objects that shouldn‚Äôt be serialized
‚úî computed values

‚∏ª

üåü Example
```java
class User implements Serializable {
    String username;
    transient String password;   // will NOT be serialized
}
```
Serialization:
```java
User u = new User("Kate", "secret123");
oos.writeObject(u);
```
Deserialization:
```java
User u = (User) ois.readObject();
```
Output:

	‚Ä¢	username: ‚ÄúKate‚Äù
	‚Ä¢	password: null (because it was transient)

‚∏ª

üåü Important Points

###  1. transient only affects Serialization

Not encryption, not hiding ‚Äî only Java serialization.

### 2. If a field is transient, during deserialization:

	‚Ä¢	primitives ‚Üí get default values
	‚Ä¢	int ‚Üí 0
	‚Ä¢	boolean ‚Üí false
	‚Ä¢	objects ‚Üí null

###‚úî 3. transient + static = always skipped

Static fields never belong to an object ‚Üí automatically not serialized.

###‚úî 4. Used in frameworks

	‚Ä¢	Hibernate: avoids serializing lazy-loaded fields
	‚Ä¢	Spring Boot: avoids serializing internal objects
	‚Ä¢	Kafka: avoid serializing unnecessary fields

‚∏ª

üåü Real-World Example
```java
class Employee implements Serializable {
    private String name;
    private transient int pinCode; // sensitive
}
```
When sending Employee object through REST API, Kafka, Redis, or writing to file:

‚úî name is serialized

‚ùå pinCode is not serialized

‚∏ª

Summary

transient is a keyword used to tell Java not to serialize that field.
During serialization it is ignored; during deserialization it becomes default value (null/0/false).
It is used for sensitive, temporary, or unnecessary fields.

‚∏ª


# Shallow vs Deep Copy

üåü What is Shallow Copy?

A shallow copy copies only the top-level object,
NOT the nested (referenced) objects.

That means:

	‚Ä¢	Primitive fields ‚Üí copied
	‚Ä¢	Object fields ‚Üí only reference copied
	
(both original and copied objects point to same inner object)

‚úî Effects:

Changing inner object in copy will affect the original.

‚úî Example (Shallow Copy):
```
class Address {
    String city;
    Address(String city) { this.city = city; }
}

class Person implements Cloneable {
    String name;
    Address address;

    Person(String name, Address address) {
        this.name = name;
        this.address = address;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone(); // Performs a shallow copy by default
    }
}

public class ShallowCopyExample {
    public static void main(String[] args) throws CloneNotSupportedException {
        Address originalAddress = new Address("New York");
        Person originalPerson = new Person("Alice", originalAddress);

        Person copiedPerson = (Person) originalPerson.clone();

        // Modifying the address in the copied object
        copiedPerson.address.city = "London";

        System.out.println("Original Person's Address: " + originalPerson.address.city); // Output: London
        System.out.println("Copied Person's Address: " + copiedPerson.address.city);   // Output: London
    }
}
```

Because both share same Address object.

‚∏ª

üåü What is Deep Copy?

A deep copy copies:

	‚Ä¢	the top-level object
	‚Ä¢	AND all nested (reference) objects recursively

Deep copy = Completely independent object.

‚úî Effects:

Changing inner object in copy does not affect original.

‚úî Example (Deep Copy):
```java
class Address {
    String city;
    Address(String city) { this.city = city; }
    // Copy constructor for Address
    Address(Address other) { this.city = other.city; }
}

class Person {
    String name;
    Address address;

    Person(String name, Address address) {
        this.name = name;
        this.address = address;
    }

    // Copy constructor for Person
    Person(Person other) {
        this.name = other.name;
        this.address = new Address(other.address); // Deep copy of Address
    }
}

public class DeepCopyExample {
    public static void main(String[] args) {
        Address originalAddress = new Address("New York");
        Person originalPerson = new Person("Alice", originalAddress);

        Person copiedPerson = new Person(originalPerson); // Using copy constructor

        // Modifying the address in the copied object
        copiedPerson.address.city = "London";

        System.out.println("Original Person's Address: " + originalPerson.address.city); // Output: New York
        System.out.println("Copied Person's Address: " + copiedPerson.address.city);   // Output: London
    }
}
```
They have separate Address objects.

‚∏ª

üåü Simple Explanation

Shallow copy copies only the object but not the objects referenced inside it.
Both original and copied object share same inner objects.

Deep copy copies everything including nested objects, so the copy is fully independent.

‚∏ª

# Multithreading

Multi-threading is a programming concept that allows multiple threads to run concurrently within a single program.

It is essential for improving the performance and responsiveness of applications.

‚∏ª

# ‚úÖ 1. What is a Thread?

A thread is the smallest unit of execution inside a process.

A Java program always has at least one thread:

‚úî main thread (created automatically by JVM).

We create additional threads to do tasks in parallel.

Threads help when:

	‚Ä¢	Doing background tasks
	‚Ä¢	Performing I/O operations
	‚Ä¢	Running periodic tasks
	‚Ä¢	Improving performance with concurrency

‚∏ª

# ‚úÖ 2. Thread Creation in Java

There are three main ways to create a thread:

‚∏ª

### A. Extending Thread class

‚úî Simple

‚úò Not flexible (can‚Äôt extend any other class)

‚∏ª

### B. Implementing Runnable

‚úî Preferred method

‚úî Reusable and more flexible

‚úî Task (Runnable) is separated from Thread

‚∏ª

### C. Using Lambda (shorter form)

### D. Using ExecutorService (Thread Pool)

For professional applications, we use ExecutorService to manage threads efficiently.

üí° Why This Is Preferred: 

‚Ä¢ Reuses threads (avoids overhead of creating new ones each time) 
‚Ä¢ Easier to manage many tasks 
‚Ä¢ Common in enterprise and Spring Boot applications

Single Example:

```java
public class ThreadsExample {
    public static void main(String[] args) throws InterruptedException {
        System.out.println("running inside main thread: " + Thread.currentThread().getName());
        ThreadA a = new ThreadA();
        a.start();

        Thread b = new Thread(new ThreadB());
        b.start();

        Thread c = new Thread(
                () -> System.out.println("inside lambda thread: " + Thread.currentThread().getName())
        );
        c.start();

        ExecutorService service = Executors.newSingleThreadExecutor();
        service.submit(() -> System.out.println("inside executor service"));

        //Daemon thread
        Thread d = new Thread(
                () -> System.out.println("inside daemon thread: " + Thread.currentThread().getName())
        );
        d.setDaemon(true);
        d.start();
        //by default JVM will not wait for this thread to finish, to make it wait
        d.join();  // waits for daemon to finish, Now JVM will wait.
    }
}

class ThreadA extends Thread {

    @Override
    public void run() {
        System.out.println("thread running via extending thread: " + Thread.currentThread().getName());
    }
}

class ThreadB implements Runnable {

    @Override
    public void run() {
        System.out.println("thread running via implementing runnable: "+ Thread.currentThread().getName());
    }
}
```

### Extra: user threads vs daemon threads

User Threads:

Keep the JVM running.

The program will not terminate until all user threads finish executing.

Daemon Threads:

Serve as background tasks.

Do not prevent the JVM from exiting when all user threads are done.

JVM can terminate once all the user threads are finished executing even though still demon threads are present and executing a logic



‚∏ª

# ‚úÖ 3. start() vs run()

### run()

	‚Ä¢	Just a normal method
	‚Ä¢	If you call it directly ‚Üí NO new thread is created
```java
t.run();   // runs in main thread
```
### start()
	‚Ä¢	Creates a new thread
	‚Ä¢	JVM calls the run() method internally in that new thread
```java
t.start(); // new thread is created
```
Simple Example

Thread t = new Thread(() -> System.out.println(Thread.currentThread().getName()));
```java
t.run();   // prints: main   (no new thread)
t.start(); // prints: Thread-0 (new thread)
```
üëâ Important: Always use start() to create actual multithreading.

‚∏ª

# ‚úÖ 4. Thread Life Cycle

Threads in Java go through 6 states according to Thread.State enum.

‚úî Thread States:
```
NEW ‚Üí RUNNABLE ‚Üí BLOCKED/WAITING/TIMED_WAITING ‚Üí RUNNABLE ‚Üí TERMINATED
```

States:

New: Thread created but start() not called.

Runnable: Thread is ready to run OR currently running on CPU.

Blocked/ Waiting / Timed Waiting: Thread is waiting to acquire a lock / Thread is waiting indefinitely for another thread to complete some action. / Thread waits for a specific time.

Terminated: Thread has completed execution.

# Race conditions

A race condition happens when two or more threads access shared data at the same time, and the final result depends on the order of execution ‚Äî which is unpredictable.

This leads to incorrect, inconsistent, or unexpected outcomes.

To fix race conditions, we must use:

	‚Ä¢	synchronized,
	‚Ä¢	locks, or
	‚Ä¢	atomic classes.

# Synchronization

Synchronization in Java is a mechanism to ensure that only one thread accesses a shared resource at a time.

Why?

To prevent race conditions and inconsistent data when multiple threads read/write shared data.


‚úî ONLY one thread to enter a critical section at a time

‚úî Other threads must wait

‚∏ª

‚úÖ Types of Synchronization (High Level)

	1.	Method-level synchronization
	2.	Block-level synchronization
	3.	Static synchronization
	
‚∏ª

### 1Ô∏è‚É£ Method-level Synchronization

A. Synchronized Instance Method
```java
public synchronized void updateBalance() {
    // critical section
}
```
Meaning:

	‚Ä¢	Lock is applied on the current object (this)
	‚Ä¢	Only one thread per object instance can access it at a time

üîí What object is locked?

The object instance ‚Üí this

‚∏ª

### 2Ô∏è‚É£ Block-level Synchronization (Most Used)
```java
public void updateBalance() {
    synchronized(this) {
        // critical section
    }
}
```
What is locked? ‚Üí this

Same effect as a synchronized method but allows finer control.

You can also synchronize on any shared object:

private final Object lock = new Object();

synchronized(lock) {
    // thread-safe work
}


‚∏ª

### 3Ô∏è‚É£ Static Synchronization
```java
public static synchronized void log() {
    // critical section
}
```
What object is locked?

‚úî Class object, i.e., ClassName.class

Meaning:

	‚Ä¢	Only one thread across all instances can access this method

‚∏ª

### üßµ How synchronized actually works (step-by-step)

When a thread enters a synchronized block:
```
	1.	Thread tries to acquire the lock on the object
	2.	If lock is free ‚Üí thread gets it and enters
	3.	If lock is held ‚Üí thread moves to BLOCKED state
	4.	When lock is released, next thread gets a chance
```
‚∏ª

üõ† Important: synchronized gives 3 guarantees
```
Feature																	Provided?
Mutual exclusion (one thread at a time)									‚úî Yes
Visible memory updates between threads									‚úî Yes
Atomicity (an operation that happens completely or not at all)			‚úî Yes (for critical section)
```

‚∏ª

üß© When to use block vs method synchronization?
```
Case							Use
Protect entire method			synchronized method
Protect only small part			synchronized block (more efficient)
Protect class-level data		static synchronized
Need custom lock object			synchronized(lockObject)
```

‚∏ª

### üß® Problems with synchronized

	‚Ä¢	Can cause deadlocks
	‚Ä¢	Thread is BLOCKED ‚Üí no timeout available
	‚Ä¢	Hard to debug
	‚Ä¢	Can reduce performance heavily with heavy contention

This is why modern code often uses:

‚úî ReentrantLock
‚úî AtomicInteger
‚úî ConcurrentHashMap
‚úî Semaphore

‚∏ª

### üöÄ Thread.sleep()

‚úÖ What it does

	‚Ä¢	Pauses the current thread for a given time.
	‚Ä¢	Thread moves to TIMED_WAITING state.
	‚Ä¢	Does NOT release any lock.
	‚Ä¢	Simply a delay.
```java
Thread.sleep(1000); // sleep 1 second
```

‚∏ª

# wait(), notify(), and notifyAll() in Java?

These are methods used for thread communication, i.e. for threads to coordinate their work.

They belong to the Object class, not the Thread class ‚Äî meaning every object in Java can be used as a lock for thread communication.

‚∏ª

üí° Real-Life Analogy

Imagine a restaurant üçΩÔ∏è:

	‚Ä¢	A chef thread prepares food.
	‚Ä¢	A waiter thread serves it.

The waiter can‚Äôt serve until the chef finishes cooking.

So the waiter waits, and when the chef is done, he notifies the waiter.

That‚Äôs what wait() and notify() do.

‚∏ª

‚öôÔ∏è The Three Methods

### 1Ô∏è‚É£ wait()

	‚Ä¢	The current thread pauses execution and releases the lock on the object.
	‚Ä¢	The thread goes into the waiting state.
	‚Ä¢	It waits until another thread calls notify() or notifyAll() on the same object.
```java
synchronized (sharedObject) {
    sharedObject.wait(); // releases the lock and waits
}
```

‚∏ª

### 2Ô∏è‚É£ notify()

	‚Ä¢	Wakes up one thread that‚Äôs waiting on the same object.
	‚Ä¢	But it doesn‚Äôt decide which thread ‚Äî the choice is JVM‚Äôs.
	‚Ä¢	The awakened thread must reacquire the lock before it can continue.
```java
synchronized (sharedObject) {
    sharedObject.notify(); // wakes up one waiting thread
}
```

‚∏ª

### 3Ô∏è‚É£ notifyAll()

	‚Ä¢	Wakes up all threads waiting on the same object.
	‚Ä¢	They all move to the runnable state, but only one thread at a time can reacquire the lock and continue.
```java
synchronized (sharedObject) {
    sharedObject.notifyAll(); // wakes up all waiting threads
}
```

‚∏ª

üß† Example ‚Äî Producer-Consumer Problem

. It demonstrates how two threads communicate safely when they share the same data.


Let‚Äôs simulate a simple queue shared between two threads:

	‚Ä¢	Producer adds items.
	‚Ä¢	Consumer removes items.
	
```java
class SharedQueue {
    private int data;
    private boolean hasData = false;

    public synchronized void produce(int value) throws InterruptedException {
        while (hasData) {
            wait(); // wait until data is consumed
        }
        data = value;
        hasData = true;
        System.out.println("Produced: " + data);
        notify(); // wake up consumer
    }

    public synchronized void consume() throws InterruptedException {
        while (!hasData) {
            wait(); // wait until data is produced
        }
        System.out.println("Consumed: " + data);
        hasData = false;
        notify(); // wake up producer
    }
}

public class WaitNotifyExample {
    public static void main(String[] args) {
        SharedQueue queue = new SharedQueue();

        Thread producer = new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                try { queue.produce(i); } catch (InterruptedException e) {}
            }
        });

        Thread consumer = new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                try { queue.consume(); } catch (InterruptedException e) {}
            }
        });

        producer.start();
        consumer.start();
    }
}
```

‚∏ª

üß© Important Rules
```
Concept							Description
Where to call					Inside a synchronized block only
What happens during wait()		Thread releases lock and waits
What happens during notify()	Wakes one waiting thread, doesn‚Äôt release lock immediately
notifyAll()						Wakes all waiting threads
Without synchronization			Throws IllegalMonitorStateException
```

‚∏ª

‚ö†Ô∏è Common Mistake

Calling wait() or notify() without synchronization:

sharedObject.wait(); // ‚ùå IllegalMonitorStateException

‚úÖ Correct usage:
```java
synchronized (sharedObject) {
    sharedObject.wait();
}
```

‚∏ª

# üîπ 1. Thread.join()

‚úÖ What it does:

	‚Ä¢	join() tells the current thread to wait for another thread to finish before continuing.

‚úÖ Why it‚Äôs useful:

	‚Ä¢	Useful when one thread depends on the result of another.
	‚Ä¢	Ensures sequential execution in multithreaded programs when needed.

üß† Syntax:

thread.join();      // Waits indefinitely
thread.join(1000);  // Waits max 1 second

üß™ Example:
```java
public class JoinExample {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            System.out.println("Thread 1 started");
            try { Thread.sleep(2000); } catch (InterruptedException e) {}
            System.out.println("Thread 1 finished");
        });

        t1.start();
        t1.join();  // Main thread waits for t1 to complete
        System.out.println("Main thread resumes after t1");
    }
}
```

‚∏ª

# üîπ 2. Thread.setPriority() and Thread Priority

‚úÖ What it does:

	‚Ä¢	Sets a thread‚Äôs priority (from 1 to 10).
	‚Ä¢	Helps the Thread Scheduler decide which thread to run first (but it‚Äôs not guaranteed).

‚úÖ Priority Range:
```
Constant	           Value
Thread.MIN_PRIORITY	    1
Thread.NORM_PRIORITY	5
Thread.MAX_PRIORITY	   10
```
‚ö†Ô∏è Important:

	‚Ä¢	Priority is just a hint to the JVM ‚Äî not always respected.
	‚Ä¢	Behavior may vary across platforms and JVM implementations.

üß™ Example:

```java
public class PriorityExample {
    public static void main(String[] args) {
        Thread low = new Thread(() -> {
            for (int i = 0; i < 5; i++) System.out.println("Low Priority");
        });
        Thread high = new Thread(() -> {
            for (int i = 0; i < 5; i++) System.out.println("High Priority");
        });

        low.setPriority(Thread.MIN_PRIORITY);
        high.setPriority(Thread.MAX_PRIORITY);

        low.start();
        high.start();
    }
}
```

‚∏ª

# volatile

volatile is a keyword in Java used to indicate that a variable‚Äôs value will be modified by multiple threads.

It guarantees:

	1.	Visibility ‚Äî changes made by one thread are immediately visible to others.
	2.	Prevents caching of the variable in thread-local memory (CPU cache).

‚∏ª

üîç Why do we need volatile?

In multithreading, each thread may cache variables for performance. So, updates made by one thread might not be seen by others.

This causes inconsistent behavior.

‚∏ª

üìå Without volatile ‚Äì Problem Example
```java
public class SharedFlag {
    private static boolean flag = false;

    public static void main(String[] args) throws InterruptedException {
        Thread thread1 = new Thread(() -> {
            while (!flag) {
                // busy wait
				//do not write sout here, because it using synchronization and it fixes visibility issue so write later to show or understand volatile
            }
            System.out.println("Thread 1 detected flag = true");
        });

        thread1.start();

        Thread.sleep(1000); // main thread sleeps

        flag = true; // main thread sets flag
        System.out.println("Main thread set flag = true");
    }
}
```
‚ùå Output (Possible):
```
Main thread set flag = true
// Thread 1 never ends!

Even though flag = true in the main thread, thread1 might not see the updated value, because it cached the variable.
```
‚∏ª

‚úÖ Fix using volatile
```java
public class SharedFlag {
    private static volatile boolean flag = false;

    public static void main(String[] args) throws InterruptedException {
        Thread thread1 = new Thread(() -> {
            while (!flag) {
                // busy wait
            }
            System.out.println("Thread 1 detected flag = true");
        });

        thread1.start();

        Thread.sleep(1000); // main thread sleeps

        flag = true; // main thread sets flag
        System.out.println("Main thread set flag = true");
    }
}

‚úÖ Output:

Main thread set flag = true
Thread 1 detected flag = true
```
Because of volatile, any update to flag by main thread is visible to thread1 immediately.

‚∏ª

# DeadLock

‚úÖ What is Deadlock?

A deadlock occurs when two or more threads are blocked forever, each waiting for a resource held by the other.

In simple words:

Thread A waits for Thread B, and Thread B waits for Thread A ‚Üí neither can progress.

‚∏ª

### üî• Simple Deadlock Example
```java
class Resource {}

public class DeadlockExample {
    private static final Object lock1 = new Object();
    private static final Object lock2 = new Object();

    public static void main(String[] args) {

        Thread t1 = new Thread(() -> {
            synchronized (lock1) {
                System.out.println("T1 locked lock1");

                try { Thread.sleep(100); } catch (Exception ignored) {}

                synchronized (lock2) {
                    System.out.println("T1 locked lock2");
                }
            }
        });

        Thread t2 = new Thread(() -> {
            synchronized (lock2) {
                System.out.println("T2 locked lock2");

                try { Thread.sleep(100); } catch (Exception ignored) {}

                synchronized (lock1) {
                    System.out.println("T2 locked lock1");
                }
            }
        });

        t1.start();
        t2.start();
    }
}
```
What happens?

	‚Ä¢	T1 acquires lock1, waits for lock2
	‚Ä¢	T2 acquires lock2, waits for lock1

‚úî Both are waiting forever ‚Üí DEADLOCK

‚∏ª

### üî• Conditions Required for Deadlock

Deadlock occurs only if all FOUR happen:

1Ô∏è‚É£ Mutual Exclusion

Only one thread at a time can hold a resource.

2Ô∏è‚É£ Hold and Wait

Thread holds one lock and waits for another.

3Ô∏è‚É£ No Preemption

Locks cannot be forcibly taken away.

4Ô∏è‚É£ Circular Wait

A ‚Üí B ‚Üí C ‚Üí A chain of waiting

If you break ANY ONE condition ‚Üí no deadlock.

‚∏ª

### üöÄ Deadlock Prevention Techniques

1Ô∏è‚É£ Always acquire locks in a FIXED ORDER (Most important)
```java
synchronized(lock1) {
    synchronized(lock2) {
        // always lock 1 ‚Üí then 2
    }
}
```
All threads must follow same order of acquiring locks.

This eliminates circular wait, therefore no deadlock.

‚∏ª

2Ô∏è‚É£ Use tryLock() with timeout (ReentrantLock)
```
if (lock1.tryLock(100, TimeUnit.MILLISECONDS)) {
    if (lock2.tryLock(100, TimeUnit.MILLISECONDS)) {
        try {
            // do work
        } finally {
            lock2.unlock();
            lock1.unlock();
        }
    } else {
        lock1.unlock();
    }
} else {
    System.out.println("Could not get locks ‚Üí avoid deadlock.");
}
```
‚úî If lock not available ‚Üí you skip waiting

‚úî Prevents deadlock from forming

‚∏ª

3Ô∏è‚É£ Use a Single Lock Instead of Multiple
```
synchronized (bigLock) {
    // protect all critical sections
}
```
Fewer locks ‚Üí simpler ‚Üí less risk.

‚∏ª

4Ô∏è‚É£ Break circular wait using hierarchy

Assign:

	‚Ä¢	lockA ‚Üí id 1
	‚Ä¢	lockB ‚Üí id 2

Always acquire smaller ID lock first.

‚∏ª

5Ô∏è‚É£ Avoid long operations inside synchronized blocks

	‚Ä¢	No I/O
	‚Ä¢	No sleep
	‚Ä¢	No network calls

They increase the chance of deadlock.

‚∏ª

6Ô∏è‚É£ Use Higher-Level Concurrency APIs

	‚Ä¢	ConcurrentHashMap
	‚Ä¢	Semaphore
	‚Ä¢	ReadWriteLock
	‚Ä¢	message queues

These reduce need for low-level locks.

‚∏ª

# Reentrant lock
ReentrantLock is reentrant, meaning a thread that already owns the lock can acquire it again without blocking.
The lock keeps a hold count.
Only when unlock() is called the same number of times as lock() the lock is released.

Example:
```java
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantExample {

    private static final ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) {
        new ReentrantExample().methodA();
    }

    public void methodA() {
        lock.lock();   // Thread acquires lock 1st time
        try {
            System.out.println("Inside methodA - lock acquired once");

            methodB(); // Call another method that tries to acquire same lock
        } finally {
            lock.unlock();
        }
    }

    public void methodB() {
        lock.lock();   // Thread acquires SAME LOCK 2nd time
        try {
            System.out.println("Inside methodB - lock acquired second time by SAME thread");
        } finally {
            lock.unlock();
        }
    }
}
```

‚∏ª

üî• Output
```
Inside methodA - lock acquired once
Inside methodB - lock acquired second time by SAME thread

```

üß† What happened?

	‚Ä¢	The Main Thread calls methodA()
	‚Ä¢	It executes lock.lock() ‚Üí acquires the lock
	‚Ä¢	Inside methodA it calls methodB()
	‚Ä¢	methodB again does lock.lock() on the same ReentrantLock
	‚Ä¢	The lock allows the same thread to acquire it again
	
‚Üí it increments the internal ‚Äúhold count‚Äù

If the lock was NOT reentrant:

üëâ methodB would block forever

üëâ because the same thread is trying to acquire a lock it already owns ‚Üí self-deadlock
‚∏ª

### ‚≠ê What is tryLock()?

tryLock() attempts to acquire the lock immediately.

‚úî If lock is free ‚Üí returns true and acquires the lock
‚úî If lock is already taken ‚Üí returns false and does NOT wait

It is non-blocking.

Example:
```java
if (lock.tryLock()) {
    try {
        System.out.println("Got the lock!");
    } finally {
        lock.unlock();
    }
} else {
    System.out.println("Did not get lock");
}
```
When to use tryLock()?

	‚Ä¢	To avoid deadlocks
	‚Ä¢	For non-blocking algorithms
	‚Ä¢	When you want the thread to move on instead of waiting

‚∏ª

### ‚≠ê tryLock(timeout) ‚Äî Wait but not forever
```java
if (lock.tryLock(500, TimeUnit.MILLISECONDS)) {
    try {
        // got lock within 500ms
    } finally {
        lock.unlock();
    }
} else {
    // tryLock failed after timeout
}
```

‚úî Good for avoiding deadlock

‚úî Good in high-contention environments

‚∏ª

### ‚≠ê unlock()

Releases the lock and allows next waiting thread to acquire it.

Important rules:

	1.	You must unlock() the same number of times you lock()
	2.	unlock() must be called only by the thread that holds the lock
	3.	Wrong thread ‚Üí IllegalMonitorStateException
	4.	Forgetting unlock() ‚Üí deadlock

‚∏ª

‚≠ê 7. Real-world example: Demonstrating lock / tryLock / unlock
```java
public class SharedResource {

    private final ReentrantLock lock = new ReentrantLock();

    public void normalLock() {
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + " got lock");
            Thread.sleep(500);
        } catch(Exception ignored) {}
        finally {
            lock.unlock();
        }
    }

    public void tryLockExample() {
        if (lock.tryLock()) {
            try {
                System.out.println(Thread.currentThread().getName() + " got lock using tryLock()");
            } finally {
                lock.unlock();
            }
        } else {
            System.out.println(Thread.currentThread().getName() + " could NOT get lock");
        }
    }
}
```

‚∏ª

‚úî ReentrantLock

	‚Ä¢	Explicit locking mechanism
	‚Ä¢	More flexible than synchronized
	‚Ä¢	Supports reentrancy
	‚Ä¢	Must unlock manually

‚úî tryLock()

	‚Ä¢	Non-blocking lock attempt
	‚Ä¢	Returns true/false immediately
	‚Ä¢	Prevents deadlocks
	‚Ä¢	Allows alternate logic

‚úî unlock()

	‚Ä¢	Releases the lock
	‚Ä¢	Must be inside finally block
	‚Ä¢	Must be called by the lock owner
	‚Ä¢	Forgetting unlock = self-deadlock

‚∏ª

# Runnable vs Callable

1Ô∏è‚É£ Runnable

	‚Ä¢	Represents a task that does not return a result.
	‚Ä¢	Cannot throw checked exceptions.
	‚Ä¢	Has a single method:

‚úÖ Simple, just executes code in a new thread, no return value.

```java
void run();
```
Example using Runnable:
```java
public class RunnableExample {
    public static void main(String[] args) {
        Runnable task = () -> {
            System.out.println("Runnable task is running.");
        };

        Thread thread = new Thread(task);
        thread.start(); // Starts the thread
    }
}
```
Output:
```
Runnable task is running.
```


‚∏ª

2Ô∏è‚É£ Callable

	‚Ä¢	Represents a task that returns a result and can throw exceptions.
	‚Ä¢	Has a single method:

V call() throws Exception;

	‚Ä¢	Works with ExecutorService to get a Future result.

Example using Callable:
```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class CallableExample {
    public static void main(String[] args) throws Exception {
        Callable<Integer> task = () -> {
            System.out.println("Callable task is running.");
            return 123; // return result
        };

        ExecutorService executor = Executors.newSingleThreadExecutor();
        Future<Integer> future = executor.submit(task);

        Integer result = future.get(); // blocks until result is available
        System.out.println("Result from Callable: " + result);

        executor.shutdown();
    }
}
```
Output:
```
Callable task is running.
Result from Callable: 123
```
‚úÖ Useful when you need a result or exception handling from a background task.

‚∏ª


# Future vs CompletableFuture (it async pipelines)

## ‚úÖ 1. Future

Future<V> is an interface introduced in Java 5 as part of java.util.concurrent.

It represents the result of an asynchronous computation.

Key Points:

	‚Ä¢	Represents a pending result of a task submitted to ExecutorService
	‚Ä¢	Can block until result is ready using get()
	‚Ä¢	Cannot easily combine multiple asynchronous tasks or chain them
	‚Ä¢	Cannot complete or trigger callback once done (no reactive support)
	‚Ä¢	Task runs asynchronously (in another thread), but retrieving the result is blocking with get().


Example:
```java
import java.util.concurrent.*;

public class FutureExample {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newSingleThreadExecutor();

        Callable<Integer> task = () -> {
            Thread.sleep(1000);
            return 42;
        };

        Future<Integer> future = executor.submit(task);

        System.out.println("Doing other work...");

        Integer result = future.get(); // blocks until task is done
        System.out.println("Result: " + result);

        executor.shutdown();
    }
}
```
‚úî Output:
```
Doing other work...
Result: 42
```

‚∏ª

## ‚úÖ 2. CompletableFuture

CompletableFuture<V> is introduced in Java 8 and is part of java.util.concurrent.

It is a powerful, flexible, and non-blocking alternative to Future.

Key Features:

	1.	Non-blocking ‚Üí supports async callbacks
	
	2.	Chainable ‚Üí allows .thenApply(), .thenAccept(), .thenCompose()
	
	3.	Can combine multiple futures (allOf, anyOf)
	
	4.	Supports manual completion (complete())
	
	5.	Supports exception handling (exceptionally())

Example:
```java
import java.util.concurrent.*;

public class CompletableFutureExample {
    public static void main(String[] args) {
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
            try { Thread.sleep(1000); } catch(Exception e) {}
            return 42;
        });

        future.thenApply(result -> result * 2)
              .thenAccept(result -> System.out.println("Result: " + result));

        System.out.println("Doing other work...");

        // Wait for completion (optional)
        future.join();
    }
}
```
‚úî Output:
```
Doing other work...
Result: 84
```

‚∏ª

üß† When to use which?

	‚Ä¢	Use Future:
	
‚úî Simple async task

‚úî Blocking get() is acceptable

	‚Ä¢	Use CompletableFuture:
	
‚úî Complex async workflows

‚úî Need chaining of multiple tasks

‚úî Need non-blocking or reactive style

‚úî Exception handling in async flow

‚∏ª

üîë Tip

Future is basic async (blocking),
CompletableFuture is advanced async (non-blocking + chainable + functional style).

‚∏ª
 Key Takeaways
 
	1.	Future = async task, blocking retrieval, no chaining ‚Üí basic async.
	
	2.	CompletableFuture = async task, non-blocking, supports async pipelines, chaining, combining, and exception handling ‚Üí modern async.
	
	3.	Async pipelines = sequence of non-blocking stages where each stage depends on the previous stage‚Äôs result.

Future:
```
ThreadPool.submit(task) ---> main thread calls future.get() ---> BLOCKS until done

CompletableFuture Async Pipeline:
Task1 (async) ---> thenApply(Task2) ---> thenAccept(Task3)
Main thread continues without blocking
```


# ExecutorService & Thread pools

ExecutorService manages a pool of threads.

Instead of creating threads manually, we submit tasks to the executor.

This improves performance, reduces memory usage, avoids too many threads, and provides clean task management.


A thread pool is a group of worker threads maintained by the ExecutorService.

```
           Submit Tasks
                |
                v
        +-----------------+
        | ExecutorService |
        +-----------------+
          /     |      \
         v      v       v
   Worker1   Worker2  Worker3   <-- Thread Pool

```

# ForkJoinPool for divide-and-conquer

It uses a technique called:

Fork ‚Üí Divide task into smaller subtasks

Join ‚Üí Combine results of subtasks

Think of it like splitting a big job into small parts, processing all parts in parallel, then merging results.

‚∏ª

Why ForkJoinPool (vs normal ExecutorService)?

Normal ExecutorService works best when:

	‚Ä¢	each task is independent
	‚Ä¢	tasks are not recursively broken down

ForkJoinPool is designed for:

	‚Ä¢	recursive tasks (divide and conquer)
	‚Ä¢	tasks that can be split into smaller tasks
	‚Ä¢	tasks that benefit from parallel computation (CPU-heavy)
	
‚∏ª	
ForkJoinPool = optimized pool for divide-and-conquer algorithms.

	‚Ä¢	Uses RecursiveTask or RecursiveAction
	‚Ä¢	Break task into small pieces (fork)
	‚Ä¢	Process pieces in parallel
	‚Ä¢	Combine results (join)
	‚Ä¢	Offers work stealing for maximum CPU usage

### Diagram of Divide & Conquer in ForkJoinPool

```
                          MAIN TASK
                              |
                     -----------------
                     |               |
                  SubTask1       SubTask2
                   |   |           |   |
                T1    T2        T3     T4

All run in parallel ‚Üí Combine results ‚Üí Final answer
```

# @Async vs ThreadPoolExecutor

@Async is only a declarative annotation for executing a method asynchronously.
It internally uses a TaskExecutor (usually ThreadPoolTaskExecutor).

If you need fine control over the thread pool (core size, max size, queue, rejection policy), configure a ThreadPoolTaskExecutor manually and point @Async to it.


# Atomic classes

Atomic classes provide lock-free, thread-safe operations using Compare-And-Set (CAS).

They prevent race conditions without using synchronized or locks, which gives better performance in multithreaded programs.

They use CPU-level atomic instructions like CAS (Compare-And-Set) to update values safely.

‚∏ª

ü§î Why Do We Need Atomic Classes?

Suppose multiple threads update a shared variable:
```java
int count = 0;

// thread A: count++
// thread B: count++
```
count++ is NOT atomic.

It expands to:

	1.	read count
	
	2.	add 1
	
	3.	write back

Two threads running this can cause race conditions.

You could use:
```
synchronized (lock) {
   count++;
}
```
But locking is slow and creates contention.

Atomic classes give you thread-safe increments without using locks.

‚∏ª

‚≠ê Common Atomic Classes
```
Atomic class						Stores				Use case
AtomicInteger						int					Counters
AtomicLong							long				Sequence IDs
AtomicBoolean						boolean				State flags
AtomicReference						Object				Updating an object atomically
AtomicIntegerArray					int[]				Atomic array updates
AtomicStampedReference / Markable	Object + version	Avoid ABA problems
```

‚∏ª

üî• How Atomic Classes Work Internally: CAS (Compare And Set)

CAS instruction:
```
Compare currentValue with expectedValue
If equal ‚Üí update to newValue
If not equal ‚Üí fail and retry
```
This avoids locking.

‚∏ª

üéØ Example 1: AtomicInteger Counter
```
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicExample {
    public static void main(String[] args) throws InterruptedException {
        
        AtomicInteger count = new AtomicInteger(0);

        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                count.incrementAndGet();  // atomic ++
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                count.incrementAndGet();  // atomic ++
            }
        });

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println("Final count: " + count.get());
    }
}
```
üéØ Output (always correct)

Final count: 2000

Because:
```
‚úî incrementAndGet() = Atomic
```
Meaning:

	‚Ä¢	It reads the value
	‚Ä¢	Adds 1
	‚Ä¢	Writes back
	‚Ä¢	Ensures no other thread interferes in between

Everything happens as one indivisible operation.

üß† Why AtomicInteger Works?

Internally, it uses CAS (Compare And Set).

It does something like this (simplified):
```
if (current value == expected value) {
    update to new value atomically
}
```
This avoids:

	‚Ä¢	locks
	‚Ä¢	synchronized
	‚Ä¢	blocking

Very fast and safe.

‚∏ª

# How does java handle pass by values and pass by reference 


### ‚úÖ KEY RULE: Java is ALWAYS pass-by-value

But what gets passed as the value depends on the type.

There is no pass-by-reference in Java.

Many people get confused because object references behave differently.

‚∏ª

## üöÄ 1. Pass-by-value for primitives

Primitive types (int, double, boolean, etc.) pass a copy of the value.

Example:
```java
void change(int x) {
    x = 10;
}

public static void main(String[] args) {
    int a = 5;
    change(a);
    System.out.println(a); // still 5
}
```
‚úî x gets a copy of a

‚úî Changing x does NOT change a

‚∏ª

## üöÄ 2. Pass-by-value for objects

This is where people get confused.

### When passing an object, Java passes a copy of the reference, NOT the object itself.

So what is passed?

value = memory address (reference)

The reference itself is copied, but both copies point to the same object.

‚∏ª

üî• Example 1: Modifying object fields works
```java
void change(Person p) {
    p.name = "Akshith";
}

public static void main(String[] args) {
    Person person = new Person("Sai");
    change(person);
    System.out.println(person.name); // "Akshith"
}
```

‚úî You modified the object

‚úî Both references point to the same object

‚úî So changes are visible

‚∏ª

üî• Example 2: Reassigning the reference does NOT change original
```java
void change(Person p) {
    p = new Person("Sairam");  // reassign reference
}

public static void main(String[] args) {
    Person person = new Person("Akshith");
    change(person);
    System.out.println(person.name); // still "Akshith"
}
```
Why?

	‚Ä¢	p received a copy of the reference.
	‚Ä¢	Changing p to point to a new object does not change the original reference.

Diagram:
```
main(): person ‚Üí (Person{name="Akshith"})
```
```
change(p):

   p = copy of person reference
   p ‚Üí new Person("Sairam")   // only p changed
```
person (original) is unaffected


‚∏ª

‚≠ê FINAL SUMMARY

‚úî Java is always pass-by-value.

What is passed?

	‚Ä¢	For primitives ‚Üí the value
	‚Ä¢	For objects ‚Üí the value of the reference (memory address)

‚úî You CAN modify the object‚Äôs internal fields

(because both references point to same object)

‚úî You CANNOT replace the original object

(because reassignment only changes the copied reference)

‚∏ª

üß† One-line:

Java is strictly pass-by-value. For objects, the value passed is a copy of the reference.
So you can modify the object via that reference, but you cannot modify which object the caller‚Äôs reference points to.

‚∏ª

# Collections

<img width="2088" height="1214" alt="image" src="https://github.com/user-attachments/assets/b06149a3-8caf-4954-8b6c-e4c7c23f2302" />

<img width="1756" height="920" alt="image" src="https://github.com/user-attachments/assets/db5fb409-4e0c-44d5-b1b6-4ad0d8e465d2" />







# Object creation for different types of classes

How do you create objects for below objects
‚Ä¢ Singleton Class
‚Ä¢ Immutability & Immutable Class
‚Ä¢ Anonymous Class
‚Ä¢ Inner Class
‚Ä¢ Static Inner Class
‚Ä¢ Nested Class
‚Ä¢ Final Class

Below is the exact way to create objects for each of the mentioned class types, with simple examples that match interview expectations.

‚∏ª

‚úÖ 1. Singleton Class

A singleton allows only one object to be created.

How to create object

You don‚Äôt use new.
You call the static getInstance() method.

Example
```java
class Singleton {
    private static final Singleton INSTANCE = new Singleton();

    private Singleton() {}   // private constructor

    public static Singleton getInstance() {
        return INSTANCE;
    }
}

class Main {
    public static void main(String[] args) {
        Singleton s = Singleton.getInstance(); // object creation
    }
}
```

‚∏ª

‚úÖ 2. Immutable Class

You create immutable objects using constructor, because the class has only final fields and no setters.

Example Immutable Class
```java
final class Person {
    private final String name;
    private final int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

Object Creation

Person p = new Person("Alice", 25);
```

‚∏ª

‚úÖ 3. Anonymous Class

Anonymous class = class without a name, created at object creation time.

Object Creation
```
You use new <interface/class>() { ... }
```
Example:
```java
Runnable r = new Runnable() {
    @Override
    public void run() {
        System.out.println("Anonymous class running");
    }
};
```

few more examples:

Anonymous Class Example 1 ‚Äî Extending a Class
```java
class Animal {
    void sound() {
        System.out.println("Some sound");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal dog = new Animal() {
            @Override
            void sound() {
                System.out.println("Dog barks");
            }
        };

        dog.sound();  // Dog barks
    }
}
```

Anonymous Class Example 2 ‚Äî Implementing Interface
```java
interface Calculator {
    int add(int a, int b);
}

public class Main {
    public static void main(String[] args) {
        Calculator calc = new Calculator() {
            @Override
            public int add(int a, int b) {
                return a + b;
            }
        };

        System.out.println(calc.add(3, 4));  // 7
    }
}
```
‚∏ª

‚úÖ 4. Inner Class (Non-static inner class)

Inner class needs an outer class object to create it.

Example:
```java
class Outer {
    class Inner {
        void show() { System.out.println("Inner"); }
    }
}
```
Object Creation
```java
Outer outer = new Outer();
Outer.Inner inner = outer.new Inner();
```

‚∏ª

‚úÖ 5. Static Inner Class

Static inner class does not need an outer class object.

Example:
```java
class Outer {
    static class Inner {
        void show() { System.out.println("Static Inner"); }
    }
}
```
Object Creation
```java
Outer.Inner inner = new Outer.Inner();
```

‚∏ª

‚úÖ 6. Nested Class

In Java, ‚Äúnested class‚Äù = inner class + static inner class.
But if interview asks separately, it means:

‚ÄúHow to create an instance of a class inside another class?‚Äù

Example:
```java
class A {
    class B {}
}
```
Object Creation
```java
A a = new A();
A.B b = a.new B();
```
(Same as inner class.)

‚∏ª

‚úÖ 7. Final Class

Final class means cannot be extended, but you can still create objects normally.

Example:
```java
final class Vehicle {
    void drive() {}
}
```
Object Creation
```java
Vehicle v = new Vehicle();
```

‚∏ª

üéØ Summary Table
```
Class Type					How to Create Object
Singleton					Singleton obj = Singleton.getInstance();
Immutable Class				ImmutableClass obj = new ImmutableClass(...);
Anonymous Class				Interface obj = new Interface() { ... }
Inner Class					Outer.Inner obj = new Outer().new Inner();
Static Inner 				Class	Outer.Inner obj = new Outer.Inner();
Nested Class				Same as inner/static inner
Final Class					FinalClass obj = new FinalClass();
```

‚∏ª


# == vs .equals()

üß© 1Ô∏è‚É£ What is == in Java?

== is a comparison operator in Java.

üëâ It checks whether two references (memory addresses) point to the same object.

It‚Äôs like asking:

‚ÄúAre these two people the exact same person?‚Äù

‚∏ª

Example 1 ‚Äî Primitives
```java
int a = 10;
int b = 10;
System.out.println(a == b);  // ‚úÖ true
```
For primitives (int, double, boolean, etc.),

== compares actual values, because they‚Äôre not objects.

‚∏ª

Example 2 ‚Äî Objects
```java
String s1 = new String("Java");
String s2 = new String("Java");

System.out.println(s1 == s2); // ‚ùå false
```
üëâ Here both strings have same content but are different objects in memory,

so == is false.

‚∏ª

### üí° Think Like This:
```
Type			What == does

Primitives		Compares values

Objects			Compares memory location / reference
```

‚∏ª

üß© 2Ô∏è‚É£ What is .equals() in Java?

.equals() is a method defined in the Object class.

Classes can override it to define what ‚Äúequality‚Äù means for them.

It‚Äôs like asking:

‚ÄúDo these two people have the same name?‚Äù

(Even if they‚Äôre not the same person.)

‚∏ª

Example 1 ‚Äî Default behavior (from Object)

### If you don‚Äôt override .equals(), it behaves like ==:
```java
class Person {
    String name;
    Person(String name) { this.name = name; }
}

Person p1 = new Person("Akshith");
Person p2 = new Person("Akshith");

System.out.println(p1.equals(p2)); // ‚ùå false
```
Because both are different objects, default .equals() compares memory.

‚∏ª

### Example 2 ‚Äî Overridden behavior (in String, Integer, etc.)
```java
String s1 = new String("Akshith");
String s2 = new String("Akshith");

System.out.println(s1.equals(s2)); // ‚úÖ true
```
Because String class overrides .equals() to compare content,
not memory.

‚∏ª

üß± 3Ô∏è‚É£ Summary: == vs .equals()
```
Comparison		Works On							Checks													Overridable?		Example
		
==				Primitives & Object References		For primitives: value  For objects: memory address		‚ùå No				s1 == s2

.equals()		Only Objects						Content (if overridden), else memory					‚úÖ Yes				s1.equals(s2)
```
‚∏ª

üß© 5Ô∏è‚É£ Real Examples

‚úÖ Example 1: Strings
```java
String s1 = "Java";
String s2 = "Java";
System.out.println(s1 == s2);       // ‚úÖ true (both point to same literal in String pool)
System.out.println(s1.equals(s2));  // ‚úÖ true (same content)

String s3 = new String("Java");
String s4 = new String("Java");
System.out.println(s3 == s4);       // ‚ùå false (different objects)
System.out.println(s3.equals(s4));  // ‚úÖ true (same content)
```

‚∏ª

‚úÖ Example 2: Integers
```java
Integer i1 = 100;
Integer i2 = 100;
System.out.println(i1 == i2);       // ‚úÖ true (cached values from -128 to 127)
System.out.println(i1.equals(i2));  // ‚úÖ true (same value)

Integer i3 = 200;
Integer i4 = 200;
System.out.println(i3 == i4);       // ‚ùå false (not cached)
System.out.println(i3.equals(i4));  // ‚úÖ true
```

‚∏ª

‚úÖ Example 3: Custom Class
```java
class Car {
    String model;
    Car(String model) { this.model = model; }
}

Car c1 = new Car("Tesla");
Car c2 = new Car("Tesla");

System.out.println(c1 == c2);       // ‚ùå false (different objects)
System.out.println(c1.equals(c2));  // ‚ùå false (not overridden)
```
If we override .equals():
```java
@Override
public boolean equals(Object o) {
    Car other = (Car) o;
    return this.model.equals(other.model);
}
```
Then:
```java
System.out.println(c1.equals(c2));  // ‚úÖ true (same content)
```

‚∏ª

üß© 6Ô∏è‚É£ In Collections

All Java Collections (List, Set, Map) use .equals() (not ==)

to check for equality of elements or keys.

For example:
```java
List<String> list = new ArrayList<>();
list.add("Java");
list.add("Java");
System.out.println(list.size()); // 2 (allows duplicates)
```
But:
```java
Set<String> set = new HashSet<>();
set.add("Java");
set.add("Java");
System.out.println(set.size()); // 1 (uses equals to detect duplicate)
```

‚∏ª

üß≠ Final 3-Line Summary (Easy to Remember)

Concept	What it does	Example

==	Compares memory / reference	Are they the same object?

.equals()	Compares content (if overridden)	Do they look the same?

Default .equals()	Same as ==	For custom classes without override


‚∏ª

üí° Think of 3 ‚Äúfamilies‚Äù:

### üè† 1. Hash Family ‚Üí hashCode + equals

Anything with ‚ÄúHash‚Äù in its name

(HashSet, HashMap, LinkedHashMap)

‚úÖ Uses hashCode + equals to find and compare elements.

üí¨ Memory Trick:

‚ÄúHash uses HashCode.‚Äù

‚∏ª

### üå≤ 2. Tree Family ‚Üí compareTo / Comparator

Anything with ‚ÄúTree‚Äù in its name

(TreeSet, TreeMap)

‚úÖ Uses compareTo() or Comparator.compare()

for equality and ordering.

üí¨ Memory Trick:

‚ÄúTree compares to grow in order.‚Äù

‚∏ª

### üì¶ 3. List Family ‚Üí equals() only

(ArrayList, LinkedList)

‚úÖ Uses equals() for contains/remove checks

üß© Keeps insertion order.

üí¨ Memory Trick:

‚ÄúList just looks for equals.‚Äù

‚∏ª


üéØ 6Ô∏è‚É£ Quick Visual Mind Map
```
Collection
 ‚î£‚îÅ‚îÅ List ‚Üí allows duplicates, uses equals()
 ‚îÉ     ‚î£‚îÅ‚îÅ ArrayList
 ‚îÉ     ‚îó‚îÅ‚îÅ LinkedList
 ‚î£‚îÅ‚îÅ Set ‚Üí no duplicates
 ‚îÉ     ‚î£‚îÅ‚îÅ HashSet (hashCode + equals)
 ‚îÉ     ‚î£‚îÅ‚îÅ LinkedHashSet (insertion order)
 ‚îÉ     ‚îó‚îÅ‚îÅ TreeSet (compareTo / Comparator)
 ‚îó‚îÅ‚îÅ Map ‚Üí key-value pairs
       ‚î£‚îÅ‚îÅ HashMap (hashCode + equals)
       ‚î£‚îÅ‚îÅ LinkedHashMap (insertion order)
       ‚îó‚îÅ‚îÅ TreeMap (compareTo / Comparator)
```

# HashMap and its internal working

### HashMap

HashMap<K, V> is a key‚Äìvalue pair data structure in Java.

It allows:

	‚Ä¢	Fast lookup (O(1) on average)
	‚Ä¢	One null key, many null values
	‚Ä¢	No guaranteed order

‚∏ª

üîπ 2. Internal Structure

A HashMap is built using an array of buckets, and each bucket can store multiple entries (nodes).

Each entry is a Node<K, V> object:
```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next; // points to the next node in case of collision
}
```
So internally:

table[] = [ Node, Node, null, Node, ... ]


‚∏ª

üîπ 3. When You Do map.put(K, V)

Let‚Äôs say:
```java
HashMap<String, Integer> map = new HashMap<>();
map.put("Akshith", 100);
```
Step-by-step process:

	1.	Compute hash code
```java
int hash = hash("Akshith");
```
HashMap calls your key‚Äôs hashCode() method and mixes it with bitwise operations to reduce collisions.
Example:
```java
hash("Akshith") ‚Üí 12345678
```

	2.	Find bucket index
```java
index = hash % capacity;
```
If the capacity is 16 ‚Üí index = 12345678 % 16 = 14.

	3.	Go to that bucket
	
	‚Ä¢	If it‚Äôs empty, create a new Node and place it there.
	‚Ä¢	If it‚Äôs not empty, there‚Äôs a collision.
	
	4.	Handle collision
	
	‚Ä¢	HashMap uses LinkedList (before Java 8) or Balanced Tree (after Java 8).
	‚Ä¢	It iterates through the nodes in that bucket:
	‚Ä¢	If the key already exists (equals() true) ‚Üí replace value.
	‚Ä¢	Else, add new node at the end.

‚∏ª

üîπ 4. When You Do map.get(K)
```java
map.get("Akshith");
```
	1.	Compute hash and index again.
	
	2.	Go to the corresponding bucket.
	
	3.	Traverse the linked list (or tree) in that bucket:
	
	‚Ä¢	For each node ‚Üí check equals() on key.
	
	4.	If found ‚Üí return value.
	
If not ‚Üí return null.

‚∏ª

üîπ 5. Treeification (Java 8+ feature)

When too many collisions happen in a single bucket (linked list > 8 elements),
HashMap converts that bucket into a balanced red-black tree.

‚úÖ Benefit ‚Üí improves lookup time from O(n) to O(log n) in that bucket.

‚∏ª

üîπ 6. Resizing (Rehashing)

When the number of entries exceeds the load factor, HashMap resizes.

	‚Ä¢	Default capacity = 16
	‚Ä¢	Default load factor = 0.75
	
‚Üí Resize happens when 16 √ó 0.75 = 12 entries

When resized:

	‚Ä¢	New capacity = old capacity √ó 2
	‚Ä¢	All existing entries are rehashed and moved to new buckets.

‚∏ª

üîπ 7. Key Methods Used Internally
```
Step	Method Used		Purpose
1		hashCode()		To compute bucket location
2		equals()		To check key equality in same bucket
3		put()			To insert or update entries
4		get()			To fetch values
5		resize()		To expand capacity when needed
```

‚∏ª

üîπ 8. Summary Flow (Visual)
```
           +-----------------------------------+
           |          HashMap Table            |
           +-----------------------------------+
		   
Index 0 ‚Üí  null
Index 1 ‚Üí  [Node(hash=123, key="Akshith", value=100, next=null)]
Index 2 ‚Üí  [Node(hash=456, key="Rahul", value=200, next=null)]
Index 3 ‚Üí  null
Index 4 ‚Üí  [Node(hash=789, key="Akshith", value=999, next=null)] ‚Üê collision
```

	‚Ä¢	Both ‚ÄúAkshith‚Äù entries go to different buckets only if hash differs.
	‚Ä¢	If same bucket, equals() decides whether to replace or append.

‚∏ª

üîπ 9. Common Interview Questions

‚úÖ Why must you override both equals() and hashCode() for custom keys?

Because HashMap first uses hashCode() to find the bucket, then equals() to find the correct key.

‚úÖ What happens if two keys have same hashCode?

They go to the same bucket ‚Üí HashMap uses equals() to differentiate them.

‚úÖ What‚Äôs the time complexity?

	‚Ä¢	Best case: O(1)
	‚Ä¢	Worst case (all elements in one bucket): O(n)
	‚Ä¢	After Java 8 with tree: worst case O(log n)



### Difference between HashMap, Hashtable, SynchronizedMap, ConcurrentHashMap

All four (HashMap, Hashtable, SynchronizedMap, ConcurrentHashMap) are key-value data structures in Java.
They differ mainly in thread safety, performance, and null handling.

‚∏ª

‚òï 1. HashMap

‚úÖ Features:

	‚Ä¢	Introduced in Java 1.2 (part of Collections Framework)
	‚Ä¢	Not thread-safe
	‚Ä¢	Allows one null key and multiple null values
	‚Ä¢	Faster than Hashtable (no synchronization)
	‚Ä¢	Backed by an array + linked list/tree (like we discussed before)

üí° Example:
```java
Map<String, Integer> map = new HashMap<>();
map.put("A", 10);
map.put(null, 20);
System.out.println(map.get(null)); // ‚úÖ Works fine
```

‚∏ª

üîí 2. Hashtable

‚úÖ Features:

	‚Ä¢	Introduced in Java 1.0 (legacy class)
	‚Ä¢	Thread-safe ‚Üí every method is synchronized
	‚Ä¢	Does NOT allow null key or value
	‚Ä¢	Slower because it locks the entire map for each operation
	‚Ä¢	Mostly deprecated for modern code

üí° Example:
```java
Map<String, Integer> table = new Hashtable<>();
table.put("A", 10);
// table.put(null, 20); ‚ùå Throws NullPointerException
```

‚∏ª

üß± 3. Synchronized HashMap

‚úÖ Features:

	‚Ä¢	A wrapper around a normal HashMap
	‚Ä¢	Created using Collections.synchronizedMap()
	‚Ä¢	Makes all operations synchronized (like Hashtable)
	‚Ä¢	Still locks the entire map during each operation
	‚Ä¢	Slightly better alternative than Hashtable (modern class)

üí° Example:
```java
Map<String, Integer> map = new HashMap<>();
Map<String, Integer> syncMap = Collections.synchronizedMap(map);

syncMap.put("A", 10);
syncMap.put("B", 20);
```
‚ö†Ô∏è Note:

Even though it‚Äôs synchronized, you must still manually synchronize during iteration:
```java
synchronized (syncMap) {
    for (String key : syncMap.keySet()) {
        System.out.println(key + " -> " + syncMap.get(key));
    }
}
```

‚∏ª

‚ö° 4. ConcurrentHashMap

‚úÖ Features:

	‚Ä¢	Introduced in Java 5 (java.util.concurrent)
	‚Ä¢	Thread-safe AND high-performance
	‚Ä¢	Uses fine-grained locking (segments/buckets)
	
‚Üí multiple threads can read/write different parts at the same time

	‚Ä¢	Does NOT allow null keys or values
	‚Ä¢	Ideal for multi-threaded environments

üí° Example:
```java
Map<String, Integer> concurrentMap = new ConcurrentHashMap<>();
concurrentMap.put("A", 10);
concurrentMap.put("B", 20);
// concurrentMap.put(null, 30); ‚ùå Throws NullPointerException
```
‚úÖ High performance: because it doesn‚Äôt lock the whole map ‚Äî only the specific bucket being modified.

‚∏ª

üß† 6. Internal Difference (Locking Mechanism)
```
Map Type			Thread Safe	Locking Mechanism	Allows null		Performance
HashMap				‚ùå No		None					‚úÖ Yes		üöÄ Fastest (single-thread)
Hashtable			‚úÖ Yes		Entire map				‚ùå No		üê¢ Slow
SynchronizedMap		‚úÖ Yes		Entire map				‚úÖ Yes		üê¢ Slow
ConcurrentHashMap	‚úÖ Yes		Per-bucket (segment)	‚ùå No		‚ö° Fast (multi-threaded)
```

‚∏ª

üß© 7. When to Use Which?
```
Situation							Recommended
Single-threaded environment			‚úÖ HashMap
Legacy code (Java 1.1 or before)	‚ò†Ô∏è Hashtable (avoid in new code)
Simple synchronization needed		‚öôÔ∏è Collections.synchronizedMap()
Multi-threaded performance			‚ö° ConcurrentHashMap
```

‚∏ª

üß† Easy Way to Remember
```
HashMap ‚Äî Fast, not safe
Hashtable ‚Äî Safe, but old and slow
SynchronizedMap ‚Äî Safe wrapper, locks whole map
ConcurrentHashMap ‚Äî Best of both worlds: safe & fast
```
