# Micro services design patterns

## Gateway Pattern

API Gateway is a single entry point for all client traffic in a microservices architecture.

It hides internal services from the client and provides routing, authentication, rate limiting, load balancing, and response aggregation.

For example, instead of the client calling order-service, payment-service, and inventory-service directly, the client calls the Gateway.

The Gateway validates the JWT token, applies rate limits, logs the request, and routes it to the appropriate service using service discovery.

In Kubernetes, the API Gateway sits behind the Ingress, uses DNS-based service discovery, and forwards traffic to services via cluster networking.

This improves security, reduces client complexity, centralizes cross-cutting concerns, and makes microservices loosely coupled.


## Service Discovery

Service Discovery allows microservices to locate each other using service names instead of changing IPs.

In Kubernetes, this is fully automatic.

Each service gets a stable DNS name (e.g., payment-service) created by CoreDNS.

When another service calls this name, Kubernetes resolves it to a stable virtual IP (ClusterIP).

kube-proxy then forwards the request to one of the actual pods behind the service.

This means even if pods restart, scale, or change IPs, microservices always communicate reliably using the service name.”


## Circuit breaker pattern

Circuit Breaker is a fault-tolerance pattern that prevents cascading failures when one microservice is down.

It works through three states: Closed (normal traffic), Open (stop calling failing service), and Half-Open (send test requests).

When a service fails repeatedly beyond a threshold, the circuit opens and the calling service immediately returns a fallback response instead of waiting for timeouts.

After some time, it allows a few trial requests in Half-Open state. If those succeed, the circuit closes again.

In microservices (e.g., using Resilience4j), this protects systems from slow or failing downstream services and keeps the whole application responsive.

## Retry Pattern

Retry Mechanism automatically re-sends a failed request because many failures in distributed systems are temporary.

It defines how many times to retry, how long to wait, and whether to use strategies like exponential backoff.

In Spring Boot, it’s implemented using libraries like Resilience4j. Retry improves reliability, but must be used carefully to avoid duplicate operations and cascading failures.
