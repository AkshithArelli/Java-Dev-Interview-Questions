‚úÖ Microservices Patterns 

1Ô∏è‚É£ API Gateway Pattern

Problem

Each microservice exposes its own API. A client shouldn‚Äôt call each service separately.

Solution

Introduce an API Gateway as a single entry point.
It routes requests ‚Üí Auth ‚Üí Load balancing ‚Üí Response aggregation.

Example

Client requests:
GET /orders/123

Flow:

Client ‚Üí API Gateway ‚Üí Order Service ‚Üí DB

API Gateway can also call multiple services:

GET /user-dashboard
‚Üí calls User-Service + Order-Service + Payment-Service
‚Üí combines response ‚Üí returns to client.

‚∏ª

2Ô∏è‚É£ Service Discovery Pattern

Problem

Microservices run dynamically (scale up/down). Their IPs keep changing.

Solution

Use Service Registry (like Eureka, Consul).
Each service registers itself and finds others through the registry.

Example

Order Service wants to call Payment Service:

Order Service ‚Üí asks Service Registry 
             ‚Üí gets Payment Service location 
             ‚Üí calls it


‚∏ª

3Ô∏è‚É£ Circuit Breaker Pattern

Problem

If Microservice B is down, Microservice A keeps calling it ‚Üí thread exhaustion ‚Üí system crash.

Solution

Use a circuit breaker (Hystrix, Resilience4j) to stop calling a failing service temporarily.

Example

If Payment Service fails continuously:

Order Service ‚Üí Circuit Breaker opens
             ‚Üí immediately returns fallback response

Fallback:

{
  "message": "Payment service unavailable. Please try later."
}


‚∏ª

4Ô∏è‚É£ Retry Pattern

Problem

Temporary network failures cause errors.

Solution

Retry the call automatically N times with delay.

Example

Order Service ‚Üí Payment Service call
Timeout?
‚Üí Retry 3 times before giving up.

‚∏ª

5Ô∏è‚É£ Bulkhead Pattern

Problem

A failure in one part can consume all resources (threads) and bring the system down.

Solution

Isolate resources (like ships with bulkheads) so failure in one area doesn‚Äôt affect others.

Example

Order Service has dedicated thread pools for:
	‚Ä¢	Payment calls
	‚Ä¢	Inventory calls

If Payment Service hangs, only its pool is blocked, but Inventory calls still work.

‚∏ª

6Ô∏è‚É£ Saga Pattern (Distributed Transactions)

Problem

How to handle a transaction across multiple microservices without a central DB transaction?

Solution

Use a series of steps, each with compensating actions when something fails.

Example Purchase Flow
	1.	Order Service ‚Üí create order
	2.	Payment Service ‚Üí deduct amount
	3.	Inventory Service ‚Üí reduce stock

If step 3 fails:
	‚Ä¢	Inventory compensation: none
	‚Ä¢	Payment compensation: refund amount
	‚Ä¢	Order compensation: cancel order

Two styles:
	‚Ä¢	Choreography (services communicate via events)
	‚Ä¢	Orchestration (a central Saga orchestrator controls flow)

‚∏ª

7Ô∏è‚É£ Event Sourcing

Problem

Need complete audit/history of changes.

Solution

Instead of saving current state, store all events (e.g., ‚ÄúOrderCreated‚Äù, ‚ÄúPaymentReceived‚Äù).

Example

Order status is never overwritten ‚Äî all events reconstruct the state.

‚∏ª

8Ô∏è‚É£ CQRS (Command Query Responsibility Segregation)

Problem

Same database model used for reads + writes ‚Üí performance issues.

Solution

Use separate models:
	‚Ä¢	Commands (writes) update data
	‚Ä¢	Queries (reads) use different optimized schema

Example

Order Service:
	‚Ä¢	Write DB is normalized (for updates)
	‚Ä¢	Read DB is denormalized (for fast dashboards)

‚∏ª

9Ô∏è‚É£ Strangler Fig Pattern

Problem

How to migrate a monolithic app into microservices gradually?

Solution

Build new microservices around the old monolith and slowly replace parts.

Example

Monolith ‚Üí Extract only ‚ÄúPayment‚Äù as microservice
Route payment requests to new service
Gradually extract more modules.

‚∏ª

üîü Database per Microservice Pattern

Problem

Shared database creates strong coupling.

Solution

Each microservice must have its own database.

Example
	‚Ä¢	Order Service ‚Üí orders_db
	‚Ä¢	Payment Service ‚Üí payments_db
	‚Ä¢	User Service ‚Üí users_db

Communicate via APIs or events, NOT DB joins.

‚∏ª

1Ô∏è‚É£1Ô∏è‚É£ Sidecar Pattern

Problem

Microservices need shared features (logging, monitoring, networking).

Solution

Deploy a helper container (sidecar) next to each service.

Example

In Kubernetes:
	‚Ä¢	app container + envoy sidecar for service mesh
Sidecar handles traffic, retries, TLS, etc.

