# Monolithic vs Microservices Architecture

Monolithic Architecture

	•	Entire application is built as one single codebase
	•	Tightly coupled components
	•	Easy to develop & deploy initially
	•	Hard to scale and maintain as application grows
	•	One failure can impact the whole system

Microservices Architecture

	•	Application is split into small, independent services
	•	Loosely coupled and independently deployable
	•	Each service owns its own database
	•	Easier to scale, fault-tolerant, and flexible
	•	Higher operational and design complexity

⸻

 # Core Components of Microservices Architecture
 
	•	API Gateway
	•	Service Discovery
	•	Configuration Server (externalized configuration)
	•	Centralized Logging
	•	Monitoring & Distributed Tracing
	•	Message Broker (Kafka / RabbitMQ for async communication)

⸻

# Scaling Strategies

## Vertical Scaling (Scale Up)

	•	Increase resources of a single machine
	•	Example: Add more CPU / RAM
	•	❌ Limited by hardware
	•	❌ Single point of failure

## Horizontal Scaling (Scale Out)

	•	Add more machines / instances
	•	Improves high availability and fault tolerance
	•	✔ Preferred approach in microservices
	•	✔ Works well with containers & Kubernetes

⸻

# Common Challenges in Microservices

## Microservices introduce challenges such as:

	•	Distributed debugging
	•	Inter-service failures
	•	Data consistency issues
	•	Complex deployments
	•	Monitoring & tracing difficulties
	•	Higher security and testing overhead

### Requires:

	•	Strong observability
	•	DevOps maturity
	•	Resilience patterns
	•	Distributed system design principles

⸻

# Service Discovery (Kubernetes)

Kubernetes provides built-in service discovery, so external registries like Eureka are not required.

How it works:

	•	Service → Stable virtual IP (ClusterIP)
	•	CoreDNS → Resolves service name to service IP
	•	Service load-balances traffic to Pods
```

      +---------------------+
      |     CoreDNS         |
      |  order-service DNS |
      +---------------------+
                 |
            DNS lookup
                 ↓
 +------------------------------+
 |  Service: order-service      |
 |  ClusterIP: 10.3.241.15      |
 +------------------------------+
        |       |       |
        ↓       ↓       ↓
     pod-1   pod-2   pod-3

```
⸻

# Inter-Service Communication & Transactions

## Communication Types

	•	REST → Synchronous communication
	•	Kafka / Message Broker → Asynchronous communication

## Transactions in Microservices

	•	Each service has its own database
	•	Distributed ACID transactions are avoided
	•	Use eventual consistency instead

## Common Patterns:

	•	Saga Pattern
	•	Outbox Pattern
	•	Compensating Transactions

⸻

# Microservices Design Patterns

## API Gateway Pattern

What is an API Gateway?

A single entry point for all client requests.

Clients never call microservices directly.

Responsibilities:

	•	Authentication & Authorization
	•	Request routing
	•	Aggregation
	•	Logging
	•	Rate limiting
	•	Caching
```
Client
   ↓
+--------------------------+
|       API Gateway        |
| - Auth                   |
| - Rate Limiting          |
| - Routing                |
+--------------------------+
           ↓
     Load Balancer
           ↓
   Multiple Service Instances
```

⸻

## Rate Limiting vs Load Balancing
```
Concept	            Purpose
Rate Limiting	  Restricts number of requests per client in a time window
Load Balancing	Distributes traffic across multiple instances
```

⸻

## Saga Design Pattern

A Saga breaks a long transaction into multiple local transactions across services.

If a step fails → compensating actions undo previous steps.

Types of Saga:

Choreography (Event-based)

	•	No central controller
	•	Services publish events
	•	If failure occurs → failure event is published
	•	Flow stops naturally

Orchestration (Central Coordinator)

	•	Central Orchestrator controls flow
	•	On failure → orchestrator triggers compensations

⸻

## Circuit Breaker + Retry + Rate Limiting

Circuit Breaker States
```
State    	  Meaning	            Behavior
Closed	    Service healthy	    Requests pass
Open	      Service down	      Requests blocked
Half-Open	  Testing recovery	  Limited test calls
```
Used with:

	•	Retry → transient failures
	•	Rate limiting → protect downstream services

⸻

## Token Bucket Algorithm

	•	Used for rate limiting
	•	Bucket holds tokens
	•	Tokens added at fixed rate
	•	Each request consumes a token
	•	No token → request rejected or delayed

✔ Allows controlled bursts
✔ Prevents system overload

⸻

## Secure Microservices Communication

	•	Basic Authentication
	•	OAuth 2.0
	•	JWT Tokens for stateless security

⸻

## RestTemplate vs WebClient (Spring)

RestTemplate

	•	Synchronous & blocking
	•	Simple API
	•	❌ Deprecated for new development
	•	❌ Not suitable for high-throughput systems

WebClient

	•	Non-blocking & reactive
	•	Supports sync + async
	•	Better performance under load
	•	Streaming & backpressure support
	•	✔ Preferred for microservices

